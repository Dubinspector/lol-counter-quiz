<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>LoL Counter Item Quiz</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">
  <style>
    :root { --pad: 14px; }
    body { font-family: system-ui, Arial, sans-serif; margin: 0; background:#0b0b0b; color:#f1f1f1; }
    header { padding: var(--pad); border-bottom: 1px solid #222; display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
    header h1 { font-size: 16px; margin: 0; font-weight: 800; }
    header .meta { font-size: 12px; color:#bdbdbd; line-height: 1.35; white-space: pre-line; }

    main { padding: var(--pad); max-width: 980px; margin: 0 auto; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }

    .card { background:#111; border:1px solid #222; border-radius: 16px; padding: 14px; }
    .row { display:flex; gap: 12px; align-items:center; }
    .avatar { width: 68px; height: 68px; border-radius: 14px; border:1px solid #222; background:#000; object-fit:cover; }
    .label { font-size: 12px; color:#bdbdbd; }
    .title { font-size: 18px; font-weight: 900; margin-top:2px; }
    .sub { font-size: 12px; color:#bdbdbd; margin-top:2px; line-height: 1.35; }

    .bar { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    button.primary {
      border-radius: 14px; border:1px solid #2a2a2a;
      background:#151515; color:#fff; padding: 12px 14px;
      cursor:pointer; touch-action: manipulation;
      font-weight: 800;
    }
    button.primary:disabled { opacity: 0.55; cursor: not-allowed; }

    .result { margin-top: 10px; font-weight: 900; }
    .ok { color:#59d36b; }
    .bad { color:#ff5c5c; }
    .small { font-size: 12px; color:#bdbdbd; line-height: 1.35; }
    .pill { padding: 6px 10px; border:1px solid #2a2a2a; border-radius: 999px; background:#121212; font-size: 12px; color:#d6d6d6; }

    footer { padding: var(--pad); color:#9a9a9a; font-size: 11px; line-height: 1.35; }

    .itemsRow { display:flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .mini { width: 44px; height: 44px; border-radius: 12px; border:1px solid #222; background:#000; object-fit:cover; }

    .analysisBox { margin-top: 10px; padding: 10px; border:1px solid #222; border-radius: 14px; background:#0e0e0e; }
    .analysisBox .t { font-weight: 900; margin-bottom: 6px; }
    .analysisBox ul { margin: 8px 0 0 16px; padding: 0; }
    .analysisBox li { margin: 4px 0; }

    #nextBtn { display:none; width:100%; }

    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .ctrl { display:flex; flex-direction:column; gap:4px; min-width: 160px; }
    .ctrl label { font-size: 11px; color:#bdbdbd; }
    select, input[type="checkbox"] { accent-color: #888; }
    select {
      border-radius: 12px;
      border:1px solid #2a2a2a;
      background:#0f0f0f;
      color:#fff;
      padding: 10px 10px;
      font-weight: 700;
      max-width: 100%;
    }
    .ctrlRow { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .chk {
      display:flex; gap:8px; align-items:center;
      padding: 10px 12px;
      border:1px solid #2a2a2a;
      border-radius: 12px;
      background:#0f0f0f;
      font-size: 12px;
      color:#e6e6e6;
      font-weight: 700;
    }

    .multiBlock { margin-top: 12px; padding: 12px; border:1px solid #222; border-radius: 14px; background:#0f0f0f; }
    .multiTitle { font-weight: 900; margin-bottom: 8px; font-size: 12px; color:#eaeaea; display:flex; gap:10px; align-items:center; }
    .enemyItemChip { display:flex; gap:8px; align-items:center; }
    .enemyItemChip img { width:32px; height:32px; border-radius:10px; border:1px solid #222; background:#000; object-fit:cover; }
    .choiceRow { display:flex; gap: 10px; flex-wrap: wrap; }
    button.choice {
      min-width: 92px; min-height: 92px;
      border-radius: 16px;
      border:1px solid #2a2a2a;
      background:#0f0f0f;
      color:#fff;
      padding: 10px;
      cursor:pointer;
      touch-action: manipulation;
    }
    button.choice:active { transform: scale(0.98); }
    button.choice:disabled { opacity: 0.55; cursor: not-allowed; }
    button.choice img { width: 56px; height: 56px; border-radius: 12px; border:1px solid #222; display:block; margin: 0 auto; background:#000; object-fit:cover; }
    button.choice .nm { font-size: 11px; color:#d8d8d8; margin-top: 8px; line-height: 1.2; text-align:center; }
    .choiceSelected { outline: 2px solid #ffffff; }
  </style>
</head>
<body>
<header>
  <div>
    <h1>LoL Counter Item Quiz</h1>
    <div class="meta" id="patchMeta">Načítám data…</div>
  </div>

  <div class="controls">
    <div class="ctrl">
      <label for="laneSel">Lane (ground truth)</label>
      <select id="laneSel"></select>
    </div>

    <div class="ctrl">
      <label for="champSel">Tvůj champion (nezávisle na lince)</label>
      <select id="champSel"></select>
    </div>

    <div class="ctrlRow">
      <div class="chk">
        <input id="lockChamp" type="checkbox">
        <label for="lockChamp">Zamknout champa</label>
      </div>
      <div class="chk">
        <input id="lockLane" type="checkbox">
        <label for="lockLane">Zamknout lane</label>
      </div>
    </div>

    <div class="bar">
      <span class="pill">Skóre: <span id="score">0</span></span>
      <span class="pill">Streak: <span id="streak">0</span></span>
      <button class="primary" id="newBtn">Start / Nové kolo</button>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <div class="label">Oponent (tap na ikonu = skilly)</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="enemyIcon" alt="">
        <div>
          <div class="title" id="enemyName">—</div>
          <div class="sub" id="enemyInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Build oponenta (dataset) – tap na item = popis</div>
      <div class="itemsRow" id="enemyBuildIcons"></div>
      <div class="sub" id="enemyBuildInfo" style="margin-top:8px;">—</div>

      <div class="label" style="margin-top:14px;">Tvůj build v dané fázi (dataset) – tap na item = popis</div>
      <div class="itemsRow" id="playerBuildIcons"></div>
      <div class="sub" id="playerBuildInfo" style="margin-top:8px;">—</div>
    </div>

    <div class="card">
      <div class="label">Ty (tap na ikonu = skilly)</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="playerIcon" alt="">
        <div>
          <div class="title" id="playerName">—</div>
          <div class="sub" id="playerInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">
        Pro KAŽDÝ enemy item vyber 1 item (1 ze 3). Pak OK.
        Správnost je empiricky z datasetu: winrate + damage-to-champions delta.
      </div>

      <div id="multiChoices"></div>

      <div class="bar" style="margin-top:12px;">
        <button class="primary" id="okBtn">OK</button>
      </div>

      <div class="result" id="result"></div>

      <div class="analysisBox" id="analysisBox" style="display:none;">
        <div class="t">Analýza (empirická + skill order)</div>
        <div class="small" id="reason"></div>
        <ul class="small" id="bullets"></ul>
      </div>

      <div style="margin-top:12px;">
        <button class="primary" id="nextBtn">Další</button>
      </div>
    </div>
  </div>
</main>

<footer>
  Fan-made projekt. Riot Games ho neschvaluje ani nesponzoruje. Assets: Riot Data Dragon. Dataset: Riot Match-V5 timeline (offline export).
</footer>

<!-- Modal -->
<div id="modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.65); padding:14px; z-index:9999;">
  <div style="max-width:720px; margin:0 auto; background:#111; border:1px solid #222; border-radius:16px; padding:14px;">
    <div style="display:flex; gap:10px; align-items:center; justify-content:space-between;">
      <div style="font-weight:900" id="modalTitle">—</div>
      <button id="modalClose" class="primary" style="padding:8px 10px;">Zavřít</button>
    </div>
    <div class="small" id="modalBody" style="margin-top:10px; line-height:1.4; white-space:pre-wrap;"></div>
  </div>
</div>

<script>
(async function () {
  if ("serviceWorker" in navigator) {
    try { await navigator.serviceWorker.register("./sw.js"); } catch (e) {}
  }

  const el = (id) => document.getElementById(id);

  const patchMeta = el("patchMeta");
  const scoreEl = el("score");
  const streakEl = el("streak");
  const newBtn = el("newBtn");
  const nextBtn = el("nextBtn");

  const laneSel = el("laneSel");
  const champSel = el("champSel");
  const lockChampEl = el("lockChamp");
  const lockLaneEl = el("lockLane");

  const okBtn = el("okBtn");
  const multiChoicesEl = el("multiChoices");

  const modal = el("modal");
  const modalTitle = el("modalTitle");
  const modalBody = el("modalBody");
  const modalClose = el("modalClose");
  modalClose.onclick = () => modal.style.display = "none";
  modal.onclick = (e) => { if (e.target === modal) modal.style.display = "none"; };

  let SCORE = 0;
  let STREAK = 0;
  let awaitingNext = false;

  const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };

  // dataset
  const logData = await fetch("./data/log_builds.json").then(r => r.json());

  // patch pin
  const versions = await fetch("https://ddragon.leagueoflegends.com/api/versions.json").then(r => r.json());
  const datasetPatch = (logData?.patch || logData?.meta?.patch || logData?.metadata?.patch || "").toString().trim();
  const patch = (datasetPatch && versions.includes(datasetPatch)) ? datasetPatch : versions[0];

  // ddragon champ list
  const champFull = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/championFull.json`).then(r => r.json());
  const champs = Object.values(champFull.data).map(c => ({
    id: c.id,
    name: c.name,
    tags: c.tags || [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/champion/${c.image.full}`
  }));

  // ddragon items raw + mapped
  const itemJson = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/item.json`).then(r => r.json());
  const rawItems = itemJson.data;
  const items = Object.entries(rawItems).map(([id, it]) => ({
    id: Number(id),
    name: it.name,
    gold: it.gold?.total ?? 0,
    tags: it.tags ?? [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/item/${it.image.full}`,
    depth: it.depth ?? 0,
    requiredChampion: it.requiredChampion ?? null,
    inStore: it.inStore !== false
  }));
  const itemById = new Map(items.map(i => [i.id, i]));

  const HARD_BANNED_ITEM_IDS = new Set([2003,2031,2033,2032,2055,3340,3363,3364,2010,2015,2019,2021,2051,2052,2138,2139,2140]);

  function isRelevantItem(it) {
    if (!it) return false;
    if (!it.inStore) return false;
    if (it.requiredChampion) return false;
    if (HARD_BANNED_ITEM_IDS.has(it.id)) return false;
    if ((it.gold ?? 0) <= 0) return false;
    const tags = new Set(it.tags || []);
    if (tags.has("Consumable")) return false;
    if (tags.has("Trinket")) return false;
    const n = (it.name || "").toLowerCase();
    if (n.includes("ward") || n.includes("trinket") || n.includes("potion") || n.includes("elixir")) return false;
    return !!it.icon;
  }

  function stripHtmlKeepLinebreaks(html) {
    const tmp = document.createElement("div");
    tmp.innerHTML = html || "";
    tmp.querySelectorAll("br").forEach(br => br.replaceWith("\n"));
    tmp.querySelectorAll("li").forEach(li => li.prepend("• "));
    const text = tmp.textContent || "";
    return text.replace(/\n{3,}/g, "\n\n").trim();
  }

  function openItemModal(it) {
    if (!it) return;
    const raw = rawItems[String(it.id)];
    const desc = stripHtmlKeepLinebreaks(raw?.description || "");
    modalTitle.textContent = it.name;
    modalBody.textContent = desc || "Popis není dostupný.";
    modal.style.display = "block";
  }

  async function fetchChampDetail(champId) {
    const url = `https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/champion/${champId}.json`;
    return fetch(url).then(r=>r.json()).catch(()=>null);
  }

  async function openChampSkillsModal(champ) {
    const det = await fetchChampDetail(champ.id);
    const data = det?.data?.[champ.id];
    if (!data) return;

    const parts = [];
    parts.push(`${data.name} – skilly`);
    parts.push("");
    for (const sp of (data.spells||[])) {
      parts.push(sp.name);
      parts.push(stripHtmlKeepLinebreaks(sp.tooltip || sp.description || ""));
      parts.push("");
    }

    modalTitle.textContent = `${data.name} – skilly`;
    modalBody.textContent = parts.join("\n");
    modal.style.display = "block";
  }

  // UI helpers
  function setChamp(side, champ, extra) {
    const img = el(`${side}Icon`);
    img.src = champ.icon;
    img.alt = champ.name;
    img.onclick = () => openChampSkillsModal(champ);
    el(`${side}Name`).textContent = champ.name;
    el(`${side}Info`).textContent = extra;
  }

  function renderIcons(containerId, itemList) {
    const wrap = el(containerId);
    wrap.innerHTML = "";
    for (const it of itemList) {
      const img = document.createElement("img");
      img.className = "mini";
      img.alt = it.name;
      img.title = it.name;
      img.src = it.icon + `?v=${Date.now()}`;
      img.onclick = () => openItemModal(it);
      img.onerror = () => img.remove();
      wrap.appendChild(img);
    }
  }

  function champFromSlug(slug) {
    const norm = (slug || "").toLowerCase().replace(/[^a-z0-9]/g,"");
    const found = champs.find(c => c.id.toLowerCase().replace(/[^a-z0-9]/g,"") === norm);
    return found || rand(champs);
  }

  function itemIdSet(list) {
    const s = new Set();
    for (const it of (list || [])) s.add(it.id);
    return s;
  }

  function phaseToWindowSec(phase) {
    const p = String(phase||"").toLowerCase();
    if (p.includes("early")) return 3;
    if (p.includes("mid")) return 6;
    return 10;
  }

  // dataset access
  function getRows(slug, laneRaw, rank, phase) {
    const rows = logData?.champions?.[slug]?.[laneRaw]?.[rank]?.[phase];
    if (!Array.isArray(rows) || rows.length === 0) return null;
    return rows;
  }
  function getTopRow(slug, laneRaw, rank, phase) {
    const rows = getRows(slug, laneRaw, rank, phase);
    return rows ? rows[0] : null;
  }
  function getRelevantItemsFromRow(row, max = 6) {
    const out = [];
    for (const x of (row?.items || [])) {
      const id = Number(x?.id || 0);
      if (!id) continue;
      const it = itemById.get(id);
      if (!isRelevantItem(it)) continue;
      out.push(it);
      if (out.length >= max) break;
    }
    return out;
  }

  // pool
  const POOL_TOP_N_ROWS = 12;
  const MIN_ITEM_WEIGHT_PCT = 3.0;
  const MIN_ITEM_ROWS = 2;
  const MIN_POOL_SIZE = 6;

  function parsePct(x) {
    if (x == null) return 0;
    if (typeof x === "number") return x;
    const s = String(x).trim().replace("%", "");
    const v = Number(s);
    return Number.isFinite(v) ? v : 0;
  }

  function getPlayerPoolFromDataset(playerSlug, laneRaw, rank, phase) {
    const rows = getRows(playerSlug, laneRaw, rank, phase);
    if (!rows) return null;

    const lim = Math.min(POOL_TOP_N_ROWS, rows.length);
    const weightByItemId = new Map();
    const rowCountByItemId = new Map();

    for (let i = 0; i < lim; i++) {
      const row = rows[i];
      const rowPick = parsePct(row?.pickRate);
      const w = rowPick > 0 ? rowPick : (1.0 / (i + 1));

      const itemsList = getRelevantItemsFromRow(row, 6) || [];
      const seenThisRow = new Set();

      for (const it of itemsList) {
        if (!isRelevantItem(it)) continue;
        weightByItemId.set(it.id, (weightByItemId.get(it.id) || 0) + w);
        if (!seenThisRow.has(it.id)) {
          seenThisRow.add(it.id);
          rowCountByItemId.set(it.id, (rowCountByItemId.get(it.id) || 0) + 1);
        }
      }
    }

    const pool = [];
    for (const [id, w] of weightByItemId.entries()) {
      const rowsSeen = rowCountByItemId.get(id) || 0;
      if (rowsSeen < MIN_ITEM_ROWS) continue;
      if (w < MIN_ITEM_WEIGHT_PCT) continue;
      const it = itemById.get(id);
      if (it && isRelevantItem(it)) pool.push(it);
    }

    pool.sort((a,b) => (weightByItemId.get(b.id)||0) - (weightByItemId.get(a.id)||0));
    return pool;
  }

  // tier match
  function tierBucket(it) {
    const g = it.gold || 0;
    const d = it.depth || 0;
    let band = 0;
    if (g <= 500) band = 0;
    else if (g <= 900) band = 1;
    else if (g <= 1400) band = 2;
    else if (g <= 2000) band = 3;
    else if (g <= 2600) band = 4;
    else if (g <= 3200) band = 5;
    else band = 6;

    let depthBand = 0;
    if (d <= 1) depthBand = 0;
    else if (d === 2) depthBand = 1;
    else if (d === 3) depthBand = 2;
    else depthBand = 3;
    return `${band}::${depthBand}`;
  }

  function pickTwoDistractorsFromPool(poolItems, correctId) {
    const correct = itemById.get(correctId);
    if (!correct) return null;

    const ctier = tierBucket(correct);
    const cgold = correct.gold || 0;
    const cdepth = correct.depth || 0;

    let candidates = poolItems.filter(it => it.id !== correctId && tierBucket(it) === ctier);

    if (candidates.length < 4) {
      candidates = poolItems.filter(it =>
        it.id !== correctId &&
        Math.abs((it.gold||0) - cgold) <= 600 &&
        Math.abs((it.depth||0) - cdepth) <= 1
      );
    }

    if (candidates.length < 2) candidates = poolItems.filter(it => it.id !== correctId);

    candidates = shuffle(candidates);
    return candidates.slice(0,2).map(x=>x.id).length === 2 ? candidates.slice(0,2).map(x=>x.id) : null;
  }

  // empirical stats
  function getEmpiricalItemStats(playerSlug, laneRaw, rank, phase, enemySlug, itemId) {
    const node = logData?.matchups?.[playerSlug]?.[laneRaw]?.[rank]?.[phase]?.[enemySlug];
    if (!node) return null;
    return node[String(itemId)] || null;
  }

  function bestEmpiricalAmong(playerSlug, laneRaw, rank, phase, enemySlug, candidateIds) {
    const MIN_GAMES = 8;
    let best = null;
    for (const id of candidateIds) {
      const s = getEmpiricalItemStats(playerSlug, laneRaw, rank, phase, enemySlug, id);
      if (!s || (s.games || 0) < MIN_GAMES) continue;
      const score = (s.winRate || 0) * 1000 + (s.estDmgWindow || 0);
      if (!best || score > best.score) best = { id, score, s };
    }
    return best;
  }

  function counterScoreHeuristic(enemyItem, candidateItem) {
    const en = (enemyItem.name || "").toLowerCase();
    const cn = (candidateItem.name || "").toLowerCase();
    let score = 0;

    const enemyArmorish = (enemyItem.tags || []).includes("Armor");
    const enemyShieldish = en.includes("sterak") || en.includes("seraph") || en.includes("shieldbow");
    const enemyLifestealish = en.includes("bloodthirst") || en.includes("ravenous") || en.includes("bork") || en.includes("riftmaker");

    const candGW = cn.includes("mortal reminder") || cn.includes("morell") || cn.includes("thornmail") || cn.includes("chempunk");
    const candArmorPen = cn.includes("lord dominik") || cn.includes("serylda") || cn.includes("black cleaver") || cn.includes("terminus");
    const candAntiShield = cn.includes("serpent");

    if (enemyLifestealish && candGW) score += 6;
    if (enemyArmorish && candArmorPen) score += 5;
    if (enemyShieldish && candAntiShield) score += 4;

    score += (candidateItem.gold || 0) / 5000;
    return score;
  }

  function getAvgSkillRanks(playerSlug, laneRaw, rank, phase) {
    return logData?.skillOrders?.[playerSlug]?.[laneRaw]?.[rank]?.[phase] || null;
  }

  // scenario index
  const allSlugs = Object.keys(logData.champions || {});
  const scenariosByPhase = new Map();
  const scenariosByLane = new Map();
  const scenariosByKey = new Map();
  let totalScenarios = 0;

  for (const enemySlug of allSlugs) {
    const lanesObj = logData.champions[enemySlug] || {};
    for (const laneRaw of Object.keys(lanesObj)) {
      const laneObj = lanesObj[laneRaw] || {};
      for (const rank of Object.keys(laneObj)) {
        const rankObj = laneObj[rank] || {};
        for (const phase of Object.keys(rankObj)) {
          const enemyRow = getTopRow(enemySlug, laneRaw, rank, phase);
          if (!enemyRow) continue;
          const enemyItems = getRelevantItemsFromRow(enemyRow, 6);
          if (!enemyItems || enemyItems.length < 1) continue;

          const sc = { laneRaw, rank, phase, enemySlug };
          const k = `${laneRaw}::${rank}::${phase}`;

          if (!scenariosByPhase.has(phase)) scenariosByPhase.set(phase, []);
          scenariosByPhase.get(phase).push(sc);

          if (!scenariosByLane.has(laneRaw)) scenariosByLane.set(laneRaw, []);
          scenariosByLane.get(laneRaw).push(sc);

          if (!scenariosByKey.has(k)) scenariosByKey.set(k, []);
          scenariosByKey.get(k).push(sc);

          totalScenarios++;
        }
      }
    }
  }
  if (totalScenarios === 0) throw new Error("Žádné scénáře v datasetu po filtrech.");

  const phaseLines = [...scenariosByPhase.entries()].sort((a,b)=>b[1].length-a[1].length).map(([p,a])=>`${p}:${a.length}`);
  const laneLines = [...scenariosByLane.entries()].sort((a,b)=>b[1].length-a[1].length).map(([l,a])=>`${l}:${a.length}`);

  patchMeta.textContent =
    `Patch: ${patch} • Dataset: data/log_builds.json\n` +
    `Scénáře: ${totalScenarios}\n` +
    `Fáze: ${phaseLines.join(" | ")}\n` +
    `Lane: ${laneLines.join(" | ")}`;

  // selectors
  const availableLanes = [...scenariosByLane.keys()].sort((a,b)=>a.localeCompare(b));
  const makeOpt = (val, txt) => {
    const o = document.createElement("option");
    o.value = val;
    o.textContent = txt;
    return o;
  };

  laneSel.innerHTML = "";
  laneSel.appendChild(makeOpt("__any__", "Náhodně"));
  for (const l of availableLanes) laneSel.appendChild(makeOpt(l, l));

  function populateChampSelect() {
    const sorted = allSlugs
      .map(slug => {
        const c = champFromSlug(slug);
        return { slug, name: c?.name || slug };
      })
      .sort((a,b)=>a.name.localeCompare(b.name));

    const prev = champSel.value;
    champSel.innerHTML = "";
    champSel.appendChild(makeOpt("__any__", "Náhodně"));
    for (const x of sorted) champSel.appendChild(makeOpt(x.slug, x.name));
    if (prev && [...champSel.options].some(o=>o.value===prev)) champSel.value = prev;
    else champSel.value = "__any__";
  }
  populateChampSelect();

  // fair phase
  const phaseList = [...scenariosByPhase.keys()];
  const resetBag = () => shuffle(phaseList);
  let phaseBag = resetBag();
  function pickPhaseFair() { if (phaseBag.length === 0) phaseBag = resetBag(); return phaseBag.pop(); }

  const laneBagByPhase = new Map();
  function nextScenarioAny(phase, forcedLane) {
    const list = scenariosByPhase.get(phase) || [];
    if (!list.length) return null;

    const filtered = forcedLane ? list.filter(sc => sc.laneRaw === forcedLane) : list;
    if (!filtered.length) return null;

    const lanes = new Map();
    for (const sc of filtered) {
      if (!lanes.has(sc.laneRaw)) lanes.set(sc.laneRaw, []);
      lanes.get(sc.laneRaw).push(sc);
    }

    const laneKeys = [...lanes.keys()];
    const weights = laneKeys.map(l => 1 / Math.max(1, lanes.get(l).length));
    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random() * sum;
    let laneRaw = laneKeys[laneKeys.length-1];
    for (let i=0;i<laneKeys.length;i++) { r -= weights[i]; if (r<=0) { laneRaw = laneKeys[i]; break; } }

    if (!laneBagByPhase.has(phase)) laneBagByPhase.set(phase, new Map());
    const m = laneBagByPhase.get(phase);
    if (!m.has(laneRaw) || m.get(laneRaw).length === 0) m.set(laneRaw, shuffle(lanes.get(laneRaw)));
    return m.get(laneRaw).pop();
  }

  const RECENT_N = 10;
  const recentEnemies = [];
  const pushRecent = (arr, v) => { arr.push(v); while (arr.length > RECENT_N) arr.shift(); };

  function lockChoices(locked) {
    multiChoicesEl.querySelectorAll("button.choice").forEach(b => b.disabled = locked);
  }

  let state = { why: "", bullets: [] };

  function renderAnalysis() {
    el("analysisBox").style.display = "block";
    el("reason").textContent = state.why;
    const ul = el("bullets");
    ul.innerHTML = "";
    for (const b of state.bullets || []) {
      const li = document.createElement("li");
      li.textContent = b;
      ul.appendChild(li);
    }
  }

  function getLockedLaneOrNull() {
    if (!lockLaneEl.checked) return null;
    const v = laneSel.value;
    if (!v || v === "__any__") return null;
    return v;
  }
  function getLockedPlayerSlugOrNull() {
    if (!lockChampEl.checked) return null;
    const v = champSel.value;
    if (!v || v === "__any__") return null;
    return v;
  }

  let multiState = {
    enemyItemsPicked: [],
    picksByEnemyItemId: new Map(),
    choicesByEnemyItemId: new Map(),
    timeWindowSec: 3
  };

  function pickEnemyItemsForQuiz(enemyItems) {
    const sorted = enemyItems.slice().sort((a,b) => ((b.depth||0)-(a.depth||0)) || ((b.gold||0)-(a.gold||0)));
    return sorted.slice(0, Math.min(3, sorted.length));
  }

  function renderMultiChoices() {
    multiChoicesEl.innerHTML = "";
    for (const eIt of multiState.enemyItemsPicked) {
      const wrap = document.createElement("div");
      wrap.className = "multiBlock";

      const title = document.createElement("div");
      title.className = "multiTitle";
      title.innerHTML = `
        <span class="enemyItemChip">
          <img src="${eIt.icon}?v=${Date.now()}" alt="${eIt.name}">
          <span>Enemy item: ${eIt.name}</span>
        </span>
      `;
      title.querySelector("img").onclick = () => openItemModal(eIt);
      wrap.appendChild(title);

      const row = document.createElement("div");
      row.className = "choiceRow";

      const ids = multiState.choicesByEnemyItemId.get(eIt.id) || [];
      for (const id of ids) {
        const it = itemById.get(id);
        const btn = document.createElement("button");
        btn.className = "choice";
        btn.innerHTML = `<img src="${it.icon}?v=${Date.now()}" alt="${it.name}"><div class="nm">${it.name}</div>`;
        btn.onclick = () => {
          multiState.picksByEnemyItemId.set(eIt.id, id);
          row.querySelectorAll("button.choice").forEach(x => x.classList.remove("choiceSelected"));
          btn.classList.add("choiceSelected");
        };
        btn.oncontextmenu = (e) => { e.preventDefault(); openItemModal(it); };
        btn.ondblclick = () => openItemModal(it);
        row.appendChild(btn);
      }

      wrap.appendChild(row);
      multiChoicesEl.appendChild(wrap);
    }
  }

  let cur = {
    laneRaw: null,
    rank: null,
    phase: null,
    enemySlug: null,
    playerSlug: null,
    enemyItems: [],
    playerItems: [],
    correctByEnemyItemId: new Map()
  };

  async function newRound() {
    awaitingNext = false;
    nextBtn.style.display = "none";
    nextBtn.disabled = true;
    newBtn.disabled = false;
    okBtn.disabled = true;

    el("result").textContent = "";
    el("result").className = "result";
    el("analysisBox").style.display = "none";
    el("reason").textContent = "";
    el("bullets").innerHTML = "";
    multiChoicesEl.innerHTML = "";

    state.why = "";
    state.bullets = [];

    const lockedLane = getLockedLaneOrNull();
    const lockedPlayerSlug = getLockedPlayerSlugOrNull();

    for (let tries = 0; tries < 5000; tries++) {
      const phase = pickPhaseFair();
      const sc = nextScenarioAny(phase, lockedLane);
      if (!sc) continue;

      const { laneRaw, rank, enemySlug } = sc;
      if (lockedLane && laneRaw !== lockedLane) continue;
      if (recentEnemies.includes(enemySlug)) continue;

      const enemyRow = getTopRow(enemySlug, laneRaw, rank, phase);
      if (!enemyRow) continue;
      const enemyItems = getRelevantItemsFromRow(enemyRow, 6);
      if (enemyItems.length < 1) continue;

      let pickedPlayerSlug = lockedPlayerSlug || null;
      if (!pickedPlayerSlug) {
        const k = `${laneRaw}::${rank}::${phase}`;
        const slugsInKey = scenariosByKey.get(k)?.map(x => x.enemySlug) || [];
        const candidatePlayers = [...new Set(slugsInKey)].filter(s => s !== enemySlug);
        if (!candidatePlayers.length) continue;
        pickedPlayerSlug = rand(candidatePlayers);
      } else {
        if (pickedPlayerSlug === enemySlug) continue;
        if (!getTopRow(pickedPlayerSlug, laneRaw, rank, phase)) continue;
      }

      const playerRow = getTopRow(pickedPlayerSlug, laneRaw, rank, phase);
      if (!playerRow) continue;
      const playerItems = getRelevantItemsFromRow(playerRow, 6);
      if (playerItems.length < 1) continue;

      const owned = itemIdSet(playerItems);

      const poolItemsRaw = getPlayerPoolFromDataset(pickedPlayerSlug, laneRaw, rank, phase);
      if (!poolItemsRaw) continue;
      const poolItems = poolItemsRaw.filter(it => !owned.has(it.id));
      if (poolItems.length < MIN_POOL_SIZE) continue;

      const quizEnemyItems = pickEnemyItemsForQuiz(enemyItems);
      if (quizEnemyItems.length < 1) continue;

      const choicesByEnemy = new Map();
      const correctByEnemy = new Map();

      for (const eIt of quizEnemyItems) {
        const candidateIds = poolItems.map(x => x.id);
        const bestEmp = bestEmpiricalAmong(pickedPlayerSlug, laneRaw, rank, phase, enemySlug, candidateIds);

        let correctId = null;
        if (bestEmp) {
          correctId = bestEmp.id;
        } else {
          let best = null;
          let bestScore = -1e9;
          for (const it of poolItems) {
            const s = counterScoreHeuristic(eIt, it);
            if (s > bestScore) { bestScore = s; best = it; }
          }
          correctId = best?.id || null;
        }
        if (!correctId) { correctByEnemy.clear(); break; }

        const wrongIds = pickTwoDistractorsFromPool(poolItems, correctId);
        if (!wrongIds) { correctByEnemy.clear(); break; }

        const ids = shuffle([correctId, ...wrongIds]);
        if (new Set(ids).size !== 3) { correctByEnemy.clear(); break; }
        if (ids.some(id => owned.has(id))) { correctByEnemy.clear(); break; }

        choicesByEnemy.set(eIt.id, ids);
        correctByEnemy.set(eIt.id, correctId);
      }

      if (correctByEnemy.size !== quizEnemyItems.length) continue;

      const enemyChamp = champFromSlug(enemySlug);
      const playerChamp = champFromSlug(pickedPlayerSlug);

      setChamp("enemy", enemyChamp, `Lane: ${laneRaw} • Rank: ${rank} • Fáze: ${phase} • Okno: ${phaseToWindowSec(phase)}s`);
      setChamp("player", playerChamp, `Lane: ${laneRaw} • Rank: ${rank} • Fáze: ${phase} • Okno: ${phaseToWindowSec(phase)}s`);

      renderIcons("enemyBuildIcons", enemyItems);
      renderIcons("playerBuildIcons", playerItems);

      el("enemyBuildInfo").textContent =
        `Pick: ${enemyRow?.pickRate ?? "—"}% • Win: ${enemyRow?.winRate ?? "—"}% • (top build)`;

      el("playerBuildInfo").textContent =
        `Pick: ${playerRow?.pickRate ?? "—"}% • Win: ${playerRow?.winRate ?? "—"}% • (top build)`;

      cur = { laneRaw, rank, phase, enemySlug, playerSlug: pickedPlayerSlug, enemyItems, playerItems, correctByEnemyItemId: correctByEnemy };

      multiState.enemyItemsPicked = quizEnemyItems;
      multiState.picksByEnemyItemId = new Map();
      multiState.choicesByEnemyItemId = choicesByEnemy;
      multiState.timeWindowSec = phaseToWindowSec(phase);

      renderMultiChoices();
      okBtn.disabled = false;

      pushRecent(recentEnemies, enemySlug);
      return;
    }

    el("result").textContent = "Chyba: nelze vygenerovat validní kolo (málo dat / lock).";
    el("result").className = "result bad";
  }

  okBtn.addEventListener("click", () => {
    if (awaitingNext) return;

    for (const eIt of multiState.enemyItemsPicked) {
      if (!multiState.picksByEnemyItemId.has(eIt.id)) {
        el("result").textContent = "Vyber item pro každý enemy item.";
        el("result").className = "result bad";
        return;
      }
    }

    awaitingNext = true;
    lockChoices(true);
    okBtn.disabled = true;
    newBtn.disabled = true;

    const bullets = [];
    const timeSec = multiState.timeWindowSec;

    let correctCount = 0;
    let total = multiState.enemyItemsPicked.length;

    bullets.push(`Okno: ${timeSec}s. Lane=${cur.laneRaw}, phase=${cur.phase}, rank=${cur.rank}.`);
    bullets.push(`Ty: ${cur.playerSlug} vs Enemy: ${cur.enemySlug}.`);

    const sr = getAvgSkillRanks(cur.playerSlug, cur.laneRaw, cur.rank, cur.phase);
    if (sr) {
      bullets.push(`Skill ranks (avg, n=${sr.n}): Q=${sr.avg.q}, W=${sr.avg.w}, E=${sr.avg.e}, R=${sr.avg.r} (lvl≈${sr.lvl}).`);
    } else {
      bullets.push(`Skill ranks: chybí data v datasetu pro tento bucket.`);
    }

    for (const eIt of multiState.enemyItemsPicked) {
      const pickedId = multiState.picksByEnemyItemId.get(eIt.id);
      const correctId = cur.correctByEnemyItemId.get(eIt.id);

      const pickedItem = itemById.get(pickedId);
      const correctItem = itemById.get(correctId);

      const pickedStats = getEmpiricalItemStats(cur.playerSlug, cur.laneRaw, cur.rank, cur.phase, cur.enemySlug, pickedId);
      const correctStats = getEmpiricalItemStats(cur.playerSlug, cur.laneRaw, cur.rank, cur.phase, cur.enemySlug, correctId);

      const pickedLine = pickedStats
        ? `WR ${pickedStats.winRate}% (n=${pickedStats.games}), dmg≈${pickedStats.estDmgWindow} v okně`
        : `bez dost dat`;
      const correctLine = correctStats
        ? `WR ${correctStats.winRate}% (n=${correctStats.games}), dmg≈${correctStats.estDmgWindow} v okně`
        : `bez dost dat (fallback heuristic)`;

      const ok = pickedId === correctId;
      if (ok) correctCount++;

      bullets.push(`Enemy item: ${eIt.name} → vybráno: ${pickedItem?.name || pickedId} (${pickedLine}) • správně: ${correctItem?.name || correctId} (${correctLine})`);
    }

    if (correctCount === total) {
      SCORE += 1; STREAK += 1;
      el("result").textContent = `SPRÁVNĚ • ${correctCount}/${total}`;
      el("result").className = "result ok";
    } else {
      STREAK = 0;
      el("result").textContent = `ŠPATNĚ • ${correctCount}/${total}`;
      el("result").className = "result bad";
    }

    scoreEl.textContent = String(SCORE);
    streakEl.textContent = String(STREAK);

    state.why =
      `Správnost je z ground truth datasetu: (tvůj champ + lane + rank + phase + enemy champ) → porovnání winrate a damage-to-champions delta (1 min okno, přepočet na ${timeSec}s).` +
      ` Tooltipy itemů/skillů jsou z Data Dragon. Skill ranks jsou empiricky z timeline eventů.`;

    state.bullets = bullets;
    renderAnalysis();

    nextBtn.style.display = "inline-block";
    nextBtn.disabled = false;
  });

  // init lane/champ selectors
  const availableLanes = [...new Set(Object.keys(Object.assign({}, ...(Object.values(logData.champions||{}).map(o=>o||{})))))]
  // previous line is not reliable; keep lanes from scenarios
  const scenarioLanes = [...new Set((() => {
    const s = [];
    for (const slug of Object.keys(logData.champions||{})) {
      for (const l of Object.keys(logData.champions[slug]||{})) s.push(l);
    }
    return s;
  })())].sort((a,b)=>a.localeCompare(b));

  laneSel.innerHTML = "";
  laneSel.appendChild(makeOpt("__any__", "Náhodně"));
  for (const l of scenarioLanes) laneSel.appendChild(makeOpt(l, l));

  // champ list from dataset
  const allSlugs = Object.keys(logData.champions||{});
  champSel.innerHTML = "";
  champSel.appendChild(makeOpt("__any__", "Náhodně"));
  for (const slug of allSlugs
    .map(slug => ({ slug, name: champFromSlug(slug)?.name || slug }))
    .sort((a,b)=>a.name.localeCompare(b.name))) {
    champSel.appendChild(makeOpt(slug.slug, slug.name));
  }

  laneSel.addEventListener("change", () => { if (!awaitingNext) newRound(); });
  champSel.addEventListener("change", () => { if (!awaitingNext) newRound(); });
  lockChampEl.addEventListener("change", () => { if (!awaitingNext) newRound(); });
  lockLaneEl.addEventListener("change", () => { if (!awaitingNext) newRound(); });

  newBtn.addEventListener("click", () => { if (!awaitingNext) newRound(); });
  nextBtn.addEventListener("click", () => newRound());

  await newRound();
})();
</script>
</body>
</html>
