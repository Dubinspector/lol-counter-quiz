<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>LoL Counter Item Quiz</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">
  <style>
    :root { --pad: 14px; }
    body { font-family: system-ui, Arial, sans-serif; margin: 0; background:#0b0b0b; color:#f1f1f1; }
    header { padding: var(--pad); border-bottom: 1px solid #222; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    header h1 { font-size: 16px; margin: 0; font-weight: 800; }
    header .meta { font-size: 12px; color:#bdbdbd; }
    main { padding: var(--pad); max-width: 980px; margin: 0 auto; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:#111; border:1px solid #222; border-radius: 16px; padding: 14px; }
    .row { display:flex; gap: 12px; align-items:center; }
    .avatar { width: 68px; height: 68px; border-radius: 14px; border:1px solid #222; background:#000; object-fit:cover; }
    .label { font-size: 12px; color:#bdbdbd; }
    .title { font-size: 18px; font-weight: 900; margin-top:2px; }
    .sub { font-size: 12px; color:#bdbdbd; margin-top:2px; }
    .choices { display:flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; }
    button.choice {
      min-width: 92px; min-height: 92px;
      border-radius: 16px;
      border:1px solid #2a2a2a;
      background:#0f0f0f;
      color:#fff;
      padding: 10px;
      cursor:pointer;
      touch-action: manipulation;
    }
    button.choice:active { transform: scale(0.98); }
    button.choice:disabled { opacity: 0.55; cursor: not-allowed; }
    button.choice img { width: 56px; height: 56px; border-radius: 12px; border:1px solid #222; display:block; margin: 0 auto; }
    button.choice .nm { font-size: 11px; color:#d8d8d8; margin-top: 8px; line-height: 1.2; text-align:center; }
    .bar { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    button.primary {
      border-radius: 14px; border:1px solid #2a2a2a;
      background:#151515; color:#fff; padding: 12px 14px;
      cursor:pointer; touch-action: manipulation;
      font-weight: 800;
    }
    button.primary:disabled { opacity: 0.55; cursor: not-allowed; }
    .result { margin-top: 10px; font-weight: 900; }
    .ok { color:#59d36b; }
    .bad { color:#ff5c5c; }
    .small { font-size: 12px; color:#bdbdbd; }
    .pill { padding: 6px 10px; border:1px solid #2a2a2a; border-radius: 999px; background:#121212; font-size: 12px; color:#d6d6d6; }
    footer { padding: var(--pad); color:#9a9a9a; font-size: 11px; line-height: 1.35; }
    .itemsRow { display:flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .mini { width: 44px; height: 44px; border-radius: 12px; border:1px solid #222; background:#000; object-fit:cover; }
    .actionsRow { display:flex; gap: 10px; margin-top: 12px; }
    #nextBtn { display:none; width:100%; }
  </style>
</head>
<body>
<header>
  <div>
    <h1>LoL Counter Item Quiz</h1>
    <div class="meta" id="patchMeta">Načítám data…</div>
  </div>
  <div class="bar">
    <span class="pill">Skóre: <span id="score">0</span></span>
    <span class="pill">Streak: <span id="streak">0</span></span>
    <button class="primary" id="newBtn">Nové kolo</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <div class="label">Oponent</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="enemyIcon" alt="">
        <div>
          <div class="title" id="enemyName">—</div>
          <div class="sub" id="enemyInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Nejhranější build (z LoG)</div>
      <div class="itemsRow" id="enemyBuildIcons"></div>
      <div class="sub" id="enemyBuildInfo" style="margin-top:8px;">—</div>
    </div>

    <div class="card">
      <div class="label">Ty</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="playerIcon" alt="">
        <div>
          <div class="title" id="playerName">—</div>
          <div class="sub" id="playerInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Vyber counter item (1 ze 3)</div>
      <div class="choices" id="choices"></div>

      <div class="result" id="result"></div>
      <div class="small" id="reason"></div>

      <div class="actionsRow">
        <button class="primary" id="nextBtn">Další</button>
      </div>
    </div>
  </div>
</main>

<footer>
  Fan-made projekt. Riot Games ho neschvaluje ani nesponzoruje. Assets: Riot Data Dragon. Statistiky: LeagueOfGraphs (offline export).
</footer>

<script>
(async function () {
  if ("serviceWorker" in navigator) {
    try { await navigator.serviceWorker.register("./sw.js"); } catch (e) {}
  }

  const el = (id) => document.getElementById(id);
  const patchMeta = el("patchMeta");
  const scoreEl = el("score");
  const streakEl = el("streak");
  const newBtn = el("newBtn");
  const nextBtn = el("nextBtn");

  let SCORE = 0;
  let STREAK = 0;
  let awaitingNext = false;

  // Patch
  const versions = await fetch("https://ddragon.leagueoflegends.com/api/versions.json").then(r => r.json());
  const patch = versions[0];
  patchMeta.textContent = `Patch: ${patch} • Dataset: data/log_builds.json • Only completed items`;

  // Champions (+ tags)
  const champJson = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/champion.json`).then(r => r.json());
  const champs = Object.values(champJson.data).map(c => ({
    id: c.id,
    name: c.name,
    tags: c.tags || [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/champion/${c.image.full}`
  }));

  // Items (keep extra fields for filtering completed items)
  const itemJson = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/item.json`).then(r => r.json());
  const rawItems = itemJson.data;

  const items = Object.entries(rawItems).map(([id, it]) => ({
    id: Number(id),
    name: it.name,
    gold: it.gold?.total ?? 0,
    tags: it.tags ?? [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/item/${it.image.full}`,
    depth: it.depth ?? 0,
    into: it.into ?? [],
    from: it.from ?? [],
    maps: it.maps ?? {},
    requiredChampion: it.requiredChampion ?? null,
    inStore: it.inStore !== false
  }));
  const itemById = new Map(items.map(i => [i.id, i]));

  // LoG dataset
  const logData = await fetch("./data/log_builds.json").then(r => r.json());

  // Game settings
  const LANES = ["top","jungle","middle","adc","support"];
  const RANKS = ["silver","gold"];
  const PHASES = ["mid","late"]; // start často obsahuje start itemy => vypnuto

  const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };

  // Exclude obvious non-learning items
  const EXCLUDE_ITEM_IDS = new Set([
    2003,2031,2033,2032, // potions
    3340,3364,3363,2055, // wards/oracle/control ward
    2010,2015,2019,2021  // biscuits/refillables (varies by patch)
  ]);

  function isCompletedItem(it) {
    if (!it) return false;
    if (!it.inStore) return false;
    if (it.requiredChampion) return false;
    if ((it.depth ?? 0) < 3) return false;     // completed items are typically depth 3
    if (it.gold <= 0) return false;
    if (EXCLUDE_ITEM_IDS.has(it.id)) return false;
    return true;
  }

  function fallbackAnyCompletedItem() {
    const pool = items.filter(isCompletedItem);
    return rand(pool).id;
  }

  // Name normalization + mapping LoG names -> Riot items
  const normalizeName = (s) =>
    (s || "")
      .toLowerCase()
      .replace(/&/g, "and")
      .replace(/[’'`"]/g, "")
      .replace(/[^a-z0-9]+/g, "")
      .trim();

  const itemByNormName = new Map();
  for (const it of items) itemByNormName.set(normalizeName(it.name), it);

  const NAME_ALIASES = new Map([
    [normalizeName("Executioner's Calling"), normalizeName("Executioners Calling")],
    [normalizeName("Lord Dominik's Regards"), normalizeName("Lord Dominiks Regards")],
    [normalizeName("Zhonya's Hourglass"), normalizeName("Zhonyas Hourglass")]
  ]);

  function getRiotItemByLoGName(logName) {
    const n = normalizeName(logName);
    if (itemByNormName.has(n)) return itemByNormName.get(n);

    for (const [a, b] of NAME_ALIASES.entries()) {
      if (n === a && itemByNormName.has(b)) return itemByNormName.get(b);
      if (n === b && itemByNormName.has(a)) return itemByNormName.get(a);
    }

    // last resort: contains
    for (const [k, v] of itemByNormName.entries()) {
      if (k.includes(n) || n.includes(k)) return v;
    }
    return null;
  }

  function riotItemIdByName(name) {
    const it = itemByNormName.get(normalizeName(name));
    return it?.id ?? null;
  }

  function findChampBySlug(slug) {
    const norm = (s) => (s || "").toLowerCase().replace(/[^a-z0-9]/g,"");
    const target = norm(slug);
    return champs.find(c => norm(c.id) === target) || rand(champs);
  }

  function playerArchetype(champ) {
    const t = new Set(champ?.tags || []);
    if (t.has("Mage") || t.has("Assassin")) return "AP";
    if (t.has("Marksman")) return "AD";
    if (t.has("Tank")) return "TANK";
    if (t.has("Support")) return "SUPPORT";
    return "AD";
  }

  // VALID POOL (only existing rows)
  const VALID_POOL = []; // {slug,lane,rank,phase}
  for (const [slug, lanesObj] of Object.entries(logData.champions || {})) {
    for (const [lane, ranksObj] of Object.entries(lanesObj || {})) {
      for (const rank of RANKS) {
        const node = ranksObj?.[rank];
        if (!node) continue;
        for (const phase of PHASES) {
          const rows = node?.[phase];
          if (Array.isArray(rows) && rows.length > 0) {
            VALID_POOL.push({ slug, lane, rank, phase });
          }
        }
      }
    }
  }
  if (VALID_POOL.length === 0) {
    throw new Error("VALID_POOL je prázdný. Dataset log_builds.json nemá žádné použitelné kombinace.");
  }

  function pickEnemyFromLog() {
    const pick = rand(VALID_POOL);
    const { slug, lane, rank, phase } = pick;
    const node = logData.champions?.[slug]?.[lane]?.[rank];
    const rows = node?.[phase] || [];
    const best = rows[0] || null;
    return { slug, lane, rank, phase, bestRow: best };
  }

  function setChamp(side, champ, extra) {
    el(`${side}Icon`).src = champ.icon;
    el(`${side}Icon`).alt = champ.name;
    el(`${side}Name`).textContent = champ.name;
    el(`${side}Info`).textContent = extra;
  }

  function renderEnemyBuildRowIcons(row) {
    const wrap = el("enemyBuildIcons");
    wrap.innerHTML = "";
    const list = (row?.items || []).slice(0, 6);
    for (const x of list) {
      const riot = getRiotItemByLoGName(x?.name);
      const use = (riot && isCompletedItem(riot)) ? riot : null;
      const img = document.createElement("img");
      img.className = "mini";
      img.alt = x?.name || "";
      img.title = x?.name || "";
      img.src = use?.icon || x?.src || "";
      wrap.appendChild(img);
    }
  }

  function pickKeyEnemyCompletedItemIdFromRow(row) {
    for (const x of (row?.items || [])) {
      const mapped = getRiotItemByLoGName(x?.name);
      if (!mapped) continue;
      const it = itemById.get(mapped.id);
      if (!isCompletedItem(it)) continue;
      return it.id;
    }
    return fallbackAnyCompletedItem();
  }

  // Counter logic (threat-based + player archetype)
  function counterForRow(enemyChampId, enemyLane, row, playerChamp) {
    const enemyIds = [];
    const enemyNamesLower = (row?.items || []).map(x => (x?.name || "").toLowerCase());

    for (const x of (row?.items || [])) {
      const mapped = getRiotItemByLoGName(x?.name);
      if (!mapped) continue;
      const it = itemById.get(mapped.id);
      if (!isCompletedItem(it)) continue;
      enemyIds.push(it.id);
    }

    const enemyText = enemyNamesLower.join(" | ");
    const arch = playerArchetype(playerChamp);

    const countTag = (tag) => enemyIds.reduce((acc,id)=>{
      const it=itemById.get(id); if(!it) return acc;
      return acc + ((it.tags||[]).includes(tag) ? 1 : 0);
    },0);

    const pick = (names, fallbackId) => {
      for (const n of names) {
        const id = riotItemIdByName(n);
        if (id && isCompletedItem(itemById.get(id))) return id;
      }
      return fallbackId;
    };

    const looksShield = ["lulu","janna","karma","shen","lux","seraphine","sion"].some(s => enemyChampId.toLowerCase().includes(s));
    const looksHeal = ["aatrox","vladimir","soraka","swain","warwick","mundo","briar","olaf"].some(s => enemyChampId.toLowerCase().includes(s)) ||
                      ["riftmaker","ravenous","bloodthirster","vamp","omnivamp"].some(s => enemyText.includes(s));
    const looksCrit = ["infinity edge","rapid firecannon","phantom dancer","statikk","navori","collector","bloodthirster","essence reaver"].some(s => enemyText.includes(s));

    const armorStack = countTag("Armor") >= 2 || countTag("Health") >= 3;
    const apStack = countTag("SpellDamage") >= 2;

    // 1) Antishield
    if (looksShield) {
      const id = pick(["Serpent's Fang"], fallbackAnyCompletedItem());
      return { itemId: id, reason: "Enemy má hodně shieldů → antishield." };
    }

    // 2) Antiheal (by archetype)
    if (looksHeal) {
      let id = null;
      if (arch === "AP") id = pick(["Morellonomicon"], null);
      if (arch === "TANK" || arch === "SUPPORT") id = pick(["Thornmail"], null);
      if (!id) id = pick(["Mortal Reminder","Chempunk Chainsword"], fallbackAnyCompletedItem());
      return { itemId: id, reason: "Enemy má sustain/heal → antiheal." };
    }

    // 3) Anti-crit / anti-AA
    if (looksCrit) {
      const id = pick(["Randuin's Omen","Frozen Heart"], fallbackAnyCompletedItem());
      return { itemId: id, reason: "Enemy je crit/autoattack DPS → anti-crit/anti-AA." };
    }

    // 4) Penetration vs armor/HP stack (not always LDR)
    if (armorStack) {
      const id = pick(["Lord Dominik's Regards","Serylda's Grudge","Black Cleaver"], fallbackAnyCompletedItem());
      return { itemId: id, reason: "Enemy stackuje armor/HP → penetration." };
    }

    // 5) MR vs AP-heavy build (basic)
    if (apStack) {
      const id = pick(["Kaenic Rookern","Force of Nature","Maw of Malmortius","Wit's End"], fallbackAnyCompletedItem());
      return { itemId: id, reason: "Enemy je silně AP → MR item." };
    }

    // 6) Fallback pool (not always Zhonya)
    const fallbackList = ["Guardian Angel","Banshee's Veil","Edge of Night","Mikael's Blessing"];
    const id = pick(fallbackList, fallbackAnyCompletedItem());
    return { itemId: id, reason: "Není jasný hard-counter → defensivní/outplay item." };
  }

  // Wrong choices: only completed items
  function pickWrongChoices(correctId) {
    const correct = itemById.get(correctId);
    const poolAll = items.filter(i => isCompletedItem(i) && i.id !== correctId);

    const correctTags = new Set(correct?.tags ?? []);
    const scored = poolAll.map(i => {
      const price = Math.abs((i.gold||0) - (correct?.gold||0));
      let tagOverlap = 0;
      for (const t of i.tags ?? []) if (correctTags.has(t)) tagOverlap++;
      const score = price - tagOverlap * 150;
      return { i, score };
    }).sort((a,b)=>a.score-b.score).slice(0, 220).map(x=>x.i);

    const out = [];
    while (out.length < 2 && scored.length) {
      const pick = rand(scored);
      if (!out.includes(pick.id) && pick.id !== correctId) out.push(pick.id);
    }
    while (out.length < 2) out.push(fallbackAnyCompletedItem());
    return out;
  }

  let state = { correctId: null, correctName: "", reason: "" };

  function lockChoices(locked) {
    const btns = document.querySelectorAll("button.choice");
    btns.forEach(b => b.disabled = locked);
  }

  async function newRound() {
    awaitingNext = false;
    nextBtn.style.display = "none";
    nextBtn.disabled = true;

    newBtn.disabled = false;

    el("result").textContent = "";
    el("result").className = "result";
    el("reason").textContent = "";
    const choicesEl = el("choices");
    choicesEl.innerHTML = "";

    const enemyPick = pickEnemyFromLog();
    const enemyChamp = findChampBySlug(enemyPick.slug);
    const playerChamp = rand(champs);

    setChamp("enemy", enemyChamp, `Lane: ${enemyPick.lane} • Rank: ${enemyPick.rank} • Fáze: ${enemyPick.phase}`);
    setChamp("player", playerChamp, `Typ: ${playerArchetype(playerChamp)}`);

    const row = enemyPick.bestRow;
    if (!row) return newRound();

    renderEnemyBuildRowIcons(row);

    const pickRate = row.pickRate ?? null;
    const winRate = row.winRate ?? null;
    el("enemyBuildInfo").textContent = `Pick: ${pickRate ?? "—"}% • Win: ${winRate ?? "—"}%`;

    // compute counter based on whole row
    const counter = counterForRow(enemyChamp.id, enemyPick.lane, row, playerChamp);

    const correctId = (counter?.itemId && isCompletedItem(itemById.get(counter.itemId))) ? counter.itemId : fallbackAnyCompletedItem();
    const wrongIds = pickWrongChoices(correctId);
    const ids = shuffle([correctId, ...wrongIds]);

    state.correctId = correctId;
    state.correctName = itemById.get(correctId)?.name ?? String(correctId);
    state.reason = counter.reason;

    for (const id of ids) {
      const it = itemById.get(id);
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.innerHTML = `<img src="${it.icon}" alt="${it.name}"><div class="nm">${it.name}</div>`;
      btn.onclick = () => onPick(id);
      choicesEl.appendChild(btn);
    }
  }

  function onPick(id) {
    if (awaitingNext) return;
    awaitingNext = true;

    lockChoices(true);
    newBtn.disabled = true;

    const ok = id === state.correctId;

    if (ok) {
      SCORE += 1;
      STREAK += 1;
      el("result").textContent = "SPRÁVNĚ";
      el("result").className = "result ok";
    } else {
      STREAK = 0;
      el("result").textContent = `ŠPATNĚ • Správně: ${state.correctName}`;
      el("result").className = "result bad";
    }

    scoreEl.textContent = String(SCORE);
    streakEl.textContent = String(STREAK);
    el("reason").textContent = state.reason;

    nextBtn.style.display = "inline-block";
    nextBtn.disabled = false;
  }

  newBtn.addEventListener("click", () => {
    if (awaitingNext) return;
    newRound();
  });

  nextBtn.addEventListener("click", () => {
    newRound();
  });

  await newRound();
})();
</script>
</body>
</html>
