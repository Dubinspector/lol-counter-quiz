<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>LoL Counter Item Quiz</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">
  <style>
    :root { --pad: 14px; }
    body { font-family: system-ui, Arial, sans-serif; margin: 0; background:#0b0b0b; color:#f1f1f1; }
    header { padding: var(--pad); border-bottom: 1px solid #222; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    header h1 { font-size: 16px; margin: 0; font-weight: 800; }
    header .meta { font-size: 12px; color:#bdbdbd; line-height: 1.35; white-space: pre-line; }
    main { padding: var(--pad); max-width: 980px; margin: 0 auto; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:#111; border:1px solid #222; border-radius: 16px; padding: 14px; }
    .row { display:flex; gap: 12px; align-items:center; }
    .avatar { width: 68px; height: 68px; border-radius: 14px; border:1px solid #222; background:#000; object-fit:cover; }
    .label { font-size: 12px; color:#bdbdbd; }
    .title { font-size: 18px; font-weight: 900; margin-top:2px; }
    .sub { font-size: 12px; color:#bdbdbd; margin-top:2px; line-height: 1.35; }
    .choices { display:flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; }
    button.choice {
      min-width: 92px; min-height: 92px;
      border-radius: 16px;
      border:1px solid #2a2a2a;
      background:#0f0f0f;
      color:#fff;
      padding: 10px;
      cursor:pointer;
      touch-action: manipulation;
    }
    button.choice:active { transform: scale(0.98); }
    button.choice:disabled { opacity: 0.55; cursor: not-allowed; }
    button.choice img { width: 56px; height: 56px; border-radius: 12px; border:1px solid #222; display:block; margin: 0 auto; background:#000; object-fit:cover; }
    button.choice .nm { font-size: 11px; color:#d8d8d8; margin-top: 8px; line-height: 1.2; text-align:center; }
    .bar { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    button.primary {
      border-radius: 14px; border:1px solid #2a2a2a;
      background:#151515; color:#fff; padding: 12px 14px;
      cursor:pointer; touch-action: manipulation;
      font-weight: 800;
    }
    button.primary:disabled { opacity: 0.55; cursor: not-allowed; }
    .result { margin-top: 10px; font-weight: 900; }
    .ok { color:#59d36b; }
    .bad { color:#ff5c5c; }
    .small { font-size: 12px; color:#bdbdbd; line-height: 1.35; }
    .pill { padding: 6px 10px; border:1px solid #2a2a2a; border-radius: 999px; background:#121212; font-size: 12px; color:#d6d6d6; }
    footer { padding: var(--pad); color:#9a9a9a; font-size: 11px; line-height: 1.35; }
    .itemsRow { display:flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .mini { width: 44px; height: 44px; border-radius: 12px; border:1px solid #222; background:#000; object-fit:cover; }
    .analysisBox { margin-top: 10px; padding: 10px; border:1px solid #222; border-radius: 14px; background:#0e0e0e; }
    .analysisBox .t { font-weight: 900; margin-bottom: 6px; }
    .analysisBox ul { margin: 8px 0 0 16px; padding: 0; }
    .analysisBox li { margin: 4px 0; }
    #nextBtn { display:none; width:100%; }
  </style>
</head>
<body>
<header>
  <div>
    <h1>LoL Counter Item Quiz</h1>
    <div class="meta" id="patchMeta">Načítám data…</div>
  </div>
  <div class="bar">
    <span class="pill">Skóre: <span id="score">0</span></span>
    <span class="pill">Streak: <span id="streak">0</span></span>
    <button class="primary" id="newBtn">Nové kolo</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <div class="label">Oponent</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="enemyIcon" alt="">
        <div>
          <div class="title" id="enemyName">—</div>
          <div class="sub" id="enemyInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Build oponenta (z exportu) – bez potion/ward/trinket</div>
      <div class="itemsRow" id="enemyBuildIcons"></div>
      <div class="sub" id="enemyBuildInfo" style="margin-top:8px;">—</div>

      <div class="label" style="margin-top:14px;">Tvůj build (z exportu) – bez potion/ward/trinket</div>
      <div class="itemsRow" id="playerBuildIcons"></div>
      <div class="sub" id="playerBuildInfo" style="margin-top:8px;">—</div>
    </div>

    <div class="card">
      <div class="label">Ty</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="playerIcon" alt="">
        <div>
          <div class="title" id="playerName">—</div>
          <div class="sub" id="playerInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Vyber counter item (1 ze 3) – stejné “tier” (gold/depth)</div>
      <div class="choices" id="choices"></div>

      <div class="result" id="result"></div>

      <div class="analysisBox" id="analysisBox" style="display:none;">
        <div class="t">Vysvětlení</div>
        <div class="small" id="reason"></div>
        <ul class="small" id="bullets"></ul>
      </div>

      <div style="margin-top:12px;">
        <button class="primary" id="nextBtn">Další</button>
      </div>
    </div>
  </div>
</main>

<footer>
  Fan-made projekt. Riot Games ho neschvaluje ani nesponzoruje. Assets: Riot Data Dragon. Statistiky: LeagueOfGraphs (offline export).
</footer>

<script>
(async function () {
  if ("serviceWorker" in navigator) {
    try { await navigator.serviceWorker.register("./sw.js"); } catch (e) {}
  }

  const el = (id) => document.getElementById(id);
  const patchMeta = el("patchMeta");
  const scoreEl = el("score");
  const streakEl = el("streak");
  const newBtn = el("newBtn");
  const nextBtn = el("nextBtn");

  let SCORE = 0;
  let STREAK = 0;
  let awaitingNext = false;

  const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };

  // ---- Load export FIRST (for patch pin) ----
  const logData = await fetch("./data/log_builds.json").then(r => r.json());

  // dataset patch pin (ground truth if present)
  const versions = await fetch("https://ddragon.leagueoflegends.com/api/versions.json").then(r => r.json());
  const datasetPatch =
    (logData?.patch || logData?.meta?.patch || logData?.metadata?.patch || "").toString().trim();

  const patch = (datasetPatch && versions.includes(datasetPatch)) ? datasetPatch : versions[0];

  // ---- DDragon ----
  const champFull = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/championFull.json`).then(r => r.json());
  const champs = Object.values(champFull.data).map(c => ({
    id: c.id,
    name: c.name,
    tags: c.tags || [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/champion/${c.image.full}`
  }));
  const champById = new Map(champs.map(c => [c.id.toLowerCase(), c]));

  const itemJson = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/item.json`).then(r => r.json());
  const rawItems = itemJson.data;
  const items = Object.entries(rawItems).map(([id, it]) => ({
    id: Number(id),
    name: it.name,
    gold: it.gold?.total ?? 0,
    tags: it.tags ?? [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/item/${it.image.full}`,
    depth: it.depth ?? 0,
    into: it.into ?? [],
    requiredChampion: it.requiredChampion ?? null,
    inStore: it.inStore !== false,
    maps: it.maps ?? null
  }));
  const itemById = new Map(items.map(i => [i.id, i]));

  // ---- CONFIG ----
  const RANKS = ["silver","gold"];
  const PHASES = ["mid","late"];

  // ---- Hard exclusions: NEVER show ----
  // Consumables, trinkets, wards, elixirs, biscuits, etc.
  const HARD_BANNED_ITEM_IDS = new Set([
    2003, 2031, 2033, 2032, // potions/biscuits
    2055,                   // control ward
    3340, 3363, 3364,       // trinkets
    2010, 2015, 2019, 2021, // biscuits/refillables etc (varies by patch)
    2052, 2051, 2138, 2139, 2140 // other consumables/elixirs (patch dependent; safe ban)
  ]);

  function isRelevantItem(it) {
    if (!it) return false;
    if (!it.inStore) return false;
    if (it.requiredChampion) return false;
    if (HARD_BANNED_ITEM_IDS.has(it.id)) return false;
    if ((it.gold ?? 0) <= 0) return false;

    // tag-based bans
    const tags = new Set(it.tags || []);
    if (tags.has("Consumable")) return false;
    if (tags.has("Trinket")) return false;

    // ward items sometimes lack tags; catch by name too
    const n = (it.name || "").toLowerCase();
    if (n.includes("ward") || n.includes("trinket") || n.includes("potion") || n.includes("elixir")) return false;

    return true;
  }

  // ---- LoG -> Riot item mapping ----
  const normalizeName = (s) =>
    (s || "")
      .toLowerCase()
      .replace(/&/g, "and")
      .replace(/[’'`"]/g, "")
      .replace(/[^a-z0-9]+/g, "")
      .trim();

  const itemByNormName = new Map();
  for (const it of items) itemByNormName.set(normalizeName(it.name), it);

  const NAME_ALIASES = new Map([
    [normalizeName("Lord Dominik's Regards"), normalizeName("Lord Dominiks Regards")],
    [normalizeName("Zhonya's Hourglass"), normalizeName("Zhonyas Hourglass")]
  ]);

  function getRiotItemByLoGName(logName) {
    const n = normalizeName(logName);
    if (itemByNormName.has(n)) return itemByNormName.get(n);

    for (const [a, b] of NAME_ALIASES.entries()) {
      if (n === a && itemByNormName.has(b)) return itemByNormName.get(b);
      if (n === b && itemByNormName.has(a)) return itemByNormName.get(a);
    }

    // fuzzy
    for (const [k, v] of itemByNormName.entries()) {
      if (k.includes(n) || n.includes(k)) return v;
    }
    return null;
  }

  function riotItemIdByName(name) {
    return itemByNormName.get(normalizeName(name))?.id ?? null;
  }

  // ---- UI helpers ----
  function setChamp(side, champ, extra) {
    el(`${side}Icon`).src = champ.icon;
    el(`${side}Icon`).alt = champ.name;
    el(`${side}Name`).textContent = champ.name;
    el(`${side}Info`).textContent = extra;
  }

  function renderIcons(containerId, itemList) {
    const wrap = el(containerId);
    wrap.innerHTML = "";
    for (const it of itemList) {
      const img = document.createElement("img");
      img.className = "mini";
      img.alt = it.name;
      img.title = it.name;
      img.src = it.icon + `?v=${Date.now()}`;
      img.onerror = () => { img.remove(); }; // we never allow rounds with missing icons (validated earlier)
      wrap.appendChild(img);
    }
  }

  function champFromSlug(slug) {
    const norm = (slug || "").toLowerCase().replace(/[^a-z0-9]/g,"");
    const found = champs.find(c => c.id.toLowerCase().replace(/[^a-z0-9]/g,"") === norm);
    return found || rand(champs);
  }

  // ---- Export readers (laneRaw is EXACT key from export) ----
  function getTopRow(slug, laneRaw, rank, phase) {
    const rows = logData?.champions?.[slug]?.[laneRaw]?.[rank]?.[phase];
    if (!Array.isArray(rows) || rows.length === 0) return null;
    return rows[0];
  }

  // Extract a "visible build" from a row:
  // - map names to riot items
  // - drop banned/irrelevant
  // - require icons exist (we validate by having icon URL)
  function getRelevantItemsFromRow(row, max = 6) {
    const out = [];
    for (const x of (row?.items || [])) {
      const mapped = getRiotItemByLoGName(x?.name);
      if (!mapped) return null; // strict: if any shown item can't map, reject this row
      const it = itemById.get(mapped.id);
      if (!isRelevantItem(it)) continue;
      if (!it.icon) return null;
      out.push(it);
      if (out.length >= max) break;
    }
    return out;
  }

  // ---- Scenario pool built ONLY from export (no guessing) ----
  const allSlugs = Object.keys(logData.champions || {});
  const playerCandidates = new Map(); // key -> [slug...]
  const key = (laneRaw, rank, phase) => `${laneRaw}::${rank}::${phase}`;

  // Collect lane keys exactly as export uses them
  const lanesInExport = new Set();
  for (const slug of allSlugs) {
    for (const laneRaw of Object.keys(logData.champions[slug] || {})) lanesInExport.add(laneRaw);
  }

  // Build candidate lists
  for (const slug of allSlugs) {
    for (const laneRaw of Object.keys(logData.champions[slug] || {})) {
      for (const rank of RANKS) for (const phase of PHASES) {
        const row = getTopRow(slug, laneRaw, rank, phase);
        if (!row) continue;

        const itemsList = getRelevantItemsFromRow(row, 6);
        if (!itemsList || itemsList.length < 2) continue; // allow early builds too (2+)

        const k = key(laneRaw, rank, phase);
        if (!playerCandidates.has(k)) playerCandidates.set(k, []);
        playerCandidates.get(k).push(slug);
      }
    }
  }

  // Scenarios grouped by laneRaw (balanced sampling)
  const scenariosByLane = new Map();
  let totalScenarios = 0;

  for (const slug of allSlugs) {
    for (const laneRaw of Object.keys(logData.champions[slug] || {})) {
      for (const rank of RANKS) for (const phase of PHASES) {
        const row = getTopRow(slug, laneRaw, rank, phase);
        if (!row) continue;

        const enemyItems = getRelevantItemsFromRow(row, 6);
        if (!enemyItems || enemyItems.length < 2) continue;

        const k = key(laneRaw, rank, phase);
        const candidates = (playerCandidates.get(k) || []).filter(s => s !== slug);
        if (candidates.length === 0) continue;

        const sc = { laneRaw, rank, phase, enemySlug: slug };
        if (!scenariosByLane.has(laneRaw)) scenariosByLane.set(laneRaw, []);
        scenariosByLane.get(laneRaw).push(sc);
        totalScenarios++;
      }
    }
  }

  if (totalScenarios === 0) throw new Error("Dataset po filtrech nemá žádné scénáře (mapování itemů/ikony).");

  // diagnostics
  const laneLines = [];
  for (const [laneRaw, arr] of [...scenariosByLane.entries()].sort((a,b)=>b[1].length-a[1].length)) {
    laneLines.push(`${laneRaw}:${arr.length}`);
  }
  patchMeta.textContent =
    `Patch: ${patch} • Dataset: data/log_builds.json\n` +
    `Scénáře: ${totalScenarios}\n` +
    `Lane scénáře: ${laneLines.join(" | ")}`;

  // balanced lane pick (no conversions; uses laneRaw)
  const lanesList = [...scenariosByLane.keys()];
  const laneWeights = lanesList.map(l => 1 / Math.max(1, scenariosByLane.get(l).length));
  const laneWeightSum = laneWeights.reduce((a,b)=>a+b,0);

  function pickLaneBalanced() {
    let r = Math.random() * laneWeightSum;
    for (let i = 0; i < lanesList.length; i++) {
      r -= laneWeights[i];
      if (r <= 0) return lanesList[i];
    }
    return lanesList[lanesList.length - 1];
  }

  const laneBags = new Map();
  function nextScenario() {
    const laneRaw = pickLaneBalanced();
    if (!laneBags.has(laneRaw) || laneBags.get(laneRaw).length === 0) {
      laneBags.set(laneRaw, shuffle(scenariosByLane.get(laneRaw)));
    }
    return laneBags.get(laneRaw).pop();
  }

  // anti-repeat champs
  const RECENT_N = 10;
  const recentEnemies = [];
  const recentPlayers = [];
  const pushRecent = (arr, v) => { arr.push(v); while (arr.length > RECENT_N) arr.shift(); };

  function pickPlayerSlug(candidates) {
    const shuffled = shuffle(candidates);
    for (const s of shuffled) if (!recentPlayers.includes(s)) return s;
    return rand(candidates);
  }

  // ---- “Tier” matching for choices ----
  function tierBucket(it) {
    const g = it.gold || 0;
    const d = it.depth || 0;
    // gold bands
    let band = 0;
    if (g <= 500) band = 0;
    else if (g <= 900) band = 1;       // e.g. Doran items / cheap starts
    else if (g <= 1400) band = 2;      // early components
    else if (g <= 2000) band = 3;      // bigger components / cheap legendaries in some patches
    else if (g <= 2600) band = 4;
    else if (g <= 3200) band = 5;
    else band = 6;

    // depth bands (meaning-ish)
    let depthBand = 0;
    if (d <= 1) depthBand = 0;         // base/starts
    else if (d === 2) depthBand = 1;
    else if (d === 3) depthBand = 2;
    else depthBand = 3;                // 4+ (rare)
    return `${band}::${depthBand}`;
  }

  function pickWrongChoices(correctId, laneRaw) {
    const correct = itemById.get(correctId);
    const correctTier = tierBucket(correct);
    const correctGold = correct.gold || 0;
    const correctDepth = correct.depth || 0;

    // candidate pool: all relevant items in ddragon, never banned, never correct
    let pool = items.filter(it => it.id !== correctId && isRelevantItem(it));

    // keep same tier bucket primarily
    const sameTier = pool.filter(it => tierBucket(it) === correctTier);
    if (sameTier.length >= 20) pool = sameTier;

    // secondary: keep gold close and depth close
    pool = pool.filter(it => Math.abs((it.gold||0) - correctGold) <= 300 && Math.abs((it.depth||0) - correctDepth) <= 1);

    // fallback if too strict
    if (pool.length < 30) {
      pool = items
        .filter(it => it.id !== correctId && isRelevantItem(it))
        .filter(it => Math.abs((it.gold||0) - correctGold) <= 600 && Math.abs((it.depth||0) - correctDepth) <= 1);
    }

    // score for plausibility (similar tags + close gold)
    const ct = new Set(correct.tags || []);
    const scored = pool.map(it => {
      let overlap = 0;
      for (const t of (it.tags||[])) if (ct.has(t)) overlap++;
      const price = Math.abs((it.gold||0) - correctGold);
      return { it, s: price - overlap * 120 };
    }).sort((a,b)=>a.s-b.s).slice(0, 250).map(x=>x.it);

    const out = [];
    while (out.length < 2 && scored.length) {
      const p = rand(scored);
      if (!out.includes(p.id) && p.id !== correctId) out.push(p.id);
    }

    // hard fallback if something goes wrong
    while (out.length < 2) {
      const p = rand(items.filter(it => isRelevantItem(it) && it.id !== correctId));
      if (!out.includes(p.id)) out.push(p.id);
    }
    return out;
  }

  // ---- Counter logic (still heuristic, but no “universal” items) ----
  // IMPORTANT: correct item is ALWAYS relevant, and wrongs are same-tier.
  const HARD_PICK_CC = new Set(["leona","nautilus","blitzcrank","thresh","rell","morgana"]);

  function counterForScenario({ laneRaw, phase, enemyChampId, enemyItems, playerItems }) {
    const enemyChamp = champById.get((enemyChampId||"").toLowerCase());
    const enemyTags = new Set(enemyChamp?.tags || []);
    const enemyNames = enemyItems.map(x => x.name.toLowerCase()).join(" | ");

    const hasHeavyArmor = enemyItems.some(it => (it.tags||[]).includes("Armor")) && enemyItems.length >= 3;
    const looksCrit = ["infinity edge","rapid firecannon","phantom dancer","statikk","navori","the collector","bloodthirster"].some(s => enemyNames.includes(s));
    const looksHeal = ["riftmaker","bloodthirster","ravenous","vamp","omnivamp"].some(s => enemyNames.includes(s));
    const looksShieldChamp = ["lulu","janna","karma","shen","lux","seraphine","sion"].includes((enemyChampId||"").toLowerCase());

    const pickExisting = (names) => {
      for (const n of names) {
        const id = riotItemIdByName(n);
        if (!id) continue;
        const it = itemById.get(id);
        if (isRelevantItem(it)) return it.id;
      }
      return null;
    };

    let correctId = null;
    let kind = "fallback";
    const bullets = [];

    if (looksShieldChamp) {
      const sf = pickExisting(["Serpent's Fang"]);
      if (sf) {
        correctId = sf;
        kind = "antishield";
        bullets.push("Enemy je shield-based → antishield zvedá efektivní damage.");
      }
    }

    if (!correctId && looksHeal) {
      const gw = pickExisting(["Morellonomicon","Thornmail","Mortal Reminder","Chempunk Chainsword"]);
      if (gw) {
        correctId = gw;
        kind = "antiheal";
        bullets.push("Enemy má sustain/heal → bez GW fight ztratíš na délku.");
      }
    }

    if (!correctId && looksCrit) {
      const anti = pickExisting(["Randuin's Omen","Frozen Heart"]);
      if (anti) {
        correctId = anti;
        kind = "anticrit";
        bullets.push("Enemy má crit/AA DPS → přežít a snížit DPS.");
      }
    }

    if (!correctId && hasHeavyArmor) {
      const pen = pickExisting(["Lord Dominik's Regards","Serylda's Grudge","Black Cleaver"]);
      if (pen) {
        correctId = pen;
        kind = "armorpen";
        bullets.push("Enemy má armor → bez pen nebudeš ubírat.");
      }
    }

    // Support-only answer only if laneRaw indicates support AND enemy is hard pick CC
    const laneLower = (laneRaw||"").toLowerCase();
    const isSupportLane = laneLower.includes("support") || laneLower === "supp";

    if (!correctId && isSupportLane) {
      const isHardPickCC = HARD_PICK_CC.has((enemyChampId||"").toLowerCase());
      if (isHardPickCC) {
        const m = pickExisting(["Mikael's Blessing"]);
        if (m) {
          correctId = m;
          kind = "cleanse";
          bullets.push("Support vs hard pick CC → Mikael zachrání carry.");
        }
      }
    }

    // fallback based on enemy tag (NOT universal)
    if (!correctId) {
      if (enemyTags.has("Assassin")) correctId = pickExisting(["Zhonya's Hourglass","Guardian Angel","Edge of Night"]);
      else if (enemyTags.has("Mage")) correctId = pickExisting(["Banshee's Veil","Force of Nature","Spirit Visage"]);
      else correctId = pickExisting(["Death's Dance","Sterak's Gage","Randuin's Omen","Frozen Heart"]);

      kind = "fallback";
      bullets.push("Bez tvrdého triggeru → defensivní/outplay item podle hrozby.");
    }

    // ABSOLUTE fallback: choose a same-tier relevant item of similar gold to enemy's most expensive item
    if (!correctId) {
      const target = enemyItems.slice().sort((a,b)=>(b.gold||0)-(a.gold||0))[0];
      const targetGold = target?.gold || 1200;
      const pool = items.filter(it => isRelevantItem(it) && Math.abs((it.gold||0) - targetGold) <= 300);
      correctId = (pool.length ? rand(pool).id : rand(items.filter(isRelevantItem)).id);
    }

    // build explanation text with actual shown items
    const phaseText = phase === "late" ? "late game" : (phase === "mid" ? "mid game" : String(phase));
    const enemyList = enemyItems.map(x=>x.name).join(", ");
    const playerList = playerItems.map(x=>x.name).join(", ");
    let why = `Lane: ${laneRaw}, ${phaseText}. Enemy: ${enemyList}. Ty: ${playerList}. `;
    if (kind === "armorpen") why += "Potřebuješ penetraci, jinak v teamfightech neprorazíš armor.";
    else if (kind === "antiheal") why += "Potřebuješ GW, jinak enemy sustain přebije výměny.";
    else if (kind === "antishield") why += "Potřebuješ antishield, jinak damage mizí ve štítech.";
    else if (kind === "anticrit") why += "Potřebuješ snížit AA/crit DPS a přežít první burst.";
    else if (kind === "cleanse") why += "Mikael je cílená odpověď na hard CC pick.";
    else why += "Bez jasného hard-counteru je správně bezpečný defensivní/outplay item proti hlavní hrozbě.";

    return { correctId, why, bullets };
  }

  // ---- Round generation (strict: no missing items) ----
  function lockChoices(locked) {
    document.querySelectorAll("button.choice").forEach(b => b.disabled = locked);
  }

  let state = { correctId: null, correctName: "", why: "", bullets: [] };

  function renderAnalysis() {
    el("analysisBox").style.display = "block";
    el("reason").textContent = state.why;
    const ul = el("bullets");
    ul.innerHTML = "";
    for (const b of state.bullets || []) {
      const li = document.createElement("li");
      li.textContent = b;
      ul.appendChild(li);
    }
  }

  async function newRound() {
    awaitingNext = false;
    nextBtn.style.display = "none";
    nextBtn.disabled = true;
    newBtn.disabled = false;

    el("result").textContent = "";
    el("result").className = "result";
    el("choices").innerHTML = "";
    el("analysisBox").style.display = "none";
    el("reason").textContent = "";
    el("bullets").innerHTML = "";

    for (let tries = 0; tries < 600; tries++) {
      const sc = nextScenario();
      const { laneRaw, rank, phase, enemySlug } = sc;

      if (recentEnemies.includes(enemySlug)) continue;

      const enemyRow = getTopRow(enemySlug, laneRaw, rank, phase);
      if (!enemyRow) continue;

      const enemyItems = getRelevantItemsFromRow(enemyRow, 6);
      if (!enemyItems || enemyItems.length < 2) continue;

      const k = key(laneRaw, rank, phase);
      const candidates = (playerCandidates.get(k) || []).filter(s => s !== enemySlug);
      if (!candidates.length) continue;

      const playerSlug = pickPlayerSlug(candidates);
      if (recentPlayers.includes(playerSlug)) continue;

      const playerRow = getTopRow(playerSlug, laneRaw, rank, phase);
      if (!playerRow) continue;

      const playerItems = getRelevantItemsFromRow(playerRow, 6);
      if (!playerItems || playerItems.length < 2) continue;

      const enemyChamp = champFromSlug(enemySlug);
      const playerChamp = champFromSlug(playerSlug);

      // STRICT: if any icon is missing URL => reroll (prevents black squares)
      if (enemyItems.some(it => !it.icon) || playerItems.some(it => !it.icon)) continue;

      setChamp("enemy", enemyChamp, `Lane: ${laneRaw} • Rank: ${rank} • Fáze: ${phase}`);
      setChamp("player", playerChamp, `Lane: ${laneRaw} • Rank: ${rank} • Fáze: ${phase}`);

      renderIcons("enemyBuildIcons", enemyItems);
      renderIcons("playerBuildIcons", playerItems);

      el("enemyBuildInfo").textContent =
        `Pick: ${enemyRow?.pickRate ?? "—"}% • Win: ${enemyRow?.winRate ?? "—"}% • (top row exportu)`;

      el("playerBuildInfo").textContent =
        `Pick: ${playerRow?.pickRate ?? "—"}% • Win: ${playerRow?.winRate ?? "—"}% • (top row exportu)`;

      const analysis = counterForScenario({
        laneRaw, phase,
        enemyChampId: enemyChamp.id,
        enemyItems,
        playerItems
      });

      const correctId = analysis.correctId;
      const wrongIds = pickWrongChoices(correctId, laneRaw);
      const ids = shuffle([correctId, ...wrongIds]);

      // ensure all 3 are relevant + have icons
      if (ids.some(id => !isRelevantItem(itemById.get(id)) || !itemById.get(id)?.icon)) continue;

      state.correctId = correctId;
      state.correctName = itemById.get(correctId)?.name ?? String(correctId);
      state.why = analysis.why;
      state.bullets = analysis.bullets;

      for (const id of ids) {
        const it = itemById.get(id);
        const btn = document.createElement("button");
        btn.className = "choice";
        btn.innerHTML = `<img src="${it.icon}?v=${Date.now()}" alt="${it.name}"><div class="nm">${it.name}</div>`;
        btn.onclick = () => onPick(id);
        el("choices").appendChild(btn);
      }

      pushRecent(recentEnemies, enemySlug);
      pushRecent(recentPlayers, playerSlug);

      return;
    }

    // If you reach here, dataset+patch mismatch or mapping broken.
    el("result").textContent = "Chyba: nelze vygenerovat validní kolo (patch/item mapping).";
    el("result").className = "result bad";
  }

  function onPick(id) {
    if (awaitingNext) return;
    awaitingNext = true;

    lockChoices(true);
    newBtn.disabled = true;

    const ok = id === state.correctId;

    if (ok) {
      SCORE += 1;
      STREAK += 1;
      el("result").textContent = "SPRÁVNĚ";
      el("result").className = "result ok";
    } else {
      STREAK = 0;
      el("result").textContent = `ŠPATNĚ • Správně: ${state.correctName}`;
      el("result").className = "result bad";
    }

    scoreEl.textContent = String(SCORE);
    streakEl.textContent = String(STREAK);

    renderAnalysis();

    nextBtn.style.display = "inline-block";
    nextBtn.disabled = false;
  }

  newBtn.addEventListener("click", () => { if (!awaitingNext) newRound(); });
  nextBtn.addEventListener("click", () => newRound());

  await newRound();
})();
</script>
</body>
</html>
