<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>LoL Counter Item Quiz</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">
  <style>
    :root { --pad: 14px; }
    body { font-family: system-ui, Arial, sans-serif; margin: 0; background:#0b0b0b; color:#f1f1f1; }
    header { padding: var(--pad); border-bottom: 1px solid #222; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    header h1 { font-size: 16px; margin: 0; font-weight: 800; }
    header .meta { font-size: 12px; color:#bdbdbd; line-height: 1.35; white-space: pre-line; }
    main { padding: var(--pad); max-width: 980px; margin: 0 auto; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:#111; border:1px solid #222; border-radius: 16px; padding: 14px; }
    .row { display:flex; gap: 12px; align-items:center; }
    .avatar { width: 68px; height: 68px; border-radius: 14px; border:1px solid #222; background:#000; object-fit:cover; }
    .label { font-size: 12px; color:#bdbdbd; }
    .title { font-size: 18px; font-weight: 900; margin-top:2px; }
    .sub { font-size: 12px; color:#bdbdbd; margin-top:2px; line-height: 1.35; }
    .choices { display:flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; }
    button.choice {
      min-width: 92px; min-height: 92px;
      border-radius: 16px;
      border:1px solid #2a2a2a;
      background:#0f0f0f;
      color:#fff;
      padding: 10px;
      cursor:pointer;
      touch-action: manipulation;
    }
    button.choice:active { transform: scale(0.98); }
    button.choice:disabled { opacity: 0.55; cursor: not-allowed; }
    button.choice img { width: 56px; height: 56px; border-radius: 12px; border:1px solid #222; display:block; margin: 0 auto; background:#000; object-fit:cover; }
    button.choice .nm { font-size: 11px; color:#d8d8d8; margin-top: 8px; line-height: 1.2; text-align:center; }
    .bar { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    button.primary {
      border-radius: 14px; border:1px solid #2a2a2a;
      background:#151515; color:#fff; padding: 12px 14px;
      cursor:pointer; touch-action: manipulation;
      font-weight: 800;
    }
    button.primary:disabled { opacity: 0.55; cursor: not-allowed; }
    .result { margin-top: 10px; font-weight: 900; }
    .ok { color:#59d36b; }
    .bad { color:#ff5c5c; }
    .small { font-size: 12px; color:#bdbdbd; line-height: 1.35; }
    .pill { padding: 6px 10px; border:1px solid #2a2a2a; border-radius: 999px; background:#121212; font-size: 12px; color:#d6d6d6; }
    footer { padding: var(--pad); color:#9a9a9a; font-size: 11px; line-height: 1.35; }
    .itemsRow { display:flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .mini { width: 44px; height: 44px; border-radius: 12px; border:1px solid #222; background:#000; object-fit:cover; }
    .analysisBox { margin-top: 10px; padding: 10px; border:1px solid #222; border-radius: 14px; background:#0e0e0e; }
    .analysisBox .t { font-weight: 900; margin-bottom: 6px; }
    .analysisBox ul { margin: 8px 0 0 16px; padding: 0; }
    .analysisBox li { margin: 4px 0; }
    #nextBtn { display:none; width:100%; }
  </style>
</head>
<body>
<header>
  <div>
    <h1>LoL Counter Item Quiz</h1>
    <div class="meta" id="patchMeta">Načítám data…</div>
  </div>
  <div class="bar">
    <span class="pill">Skóre: <span id="score">0</span></span>
    <span class="pill">Streak: <span id="streak">0</span></span>
    <button class="primary" id="newBtn">Nové kolo</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card">
      <div class="label">Oponent</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="enemyIcon" alt="">
        <div>
          <div class="title" id="enemyName">—</div>
          <div class="sub" id="enemyInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Build oponenta (z exportu) – bez potion/ward/trinket</div>
      <div class="itemsRow" id="enemyBuildIcons"></div>
      <div class="sub" id="enemyBuildInfo" style="margin-top:8px;">—</div>

      <div class="label" style="margin-top:14px;">Tvůj build (z exportu) – bez potion/ward/trinket</div>
      <div class="itemsRow" id="playerBuildIcons"></div>
      <div class="sub" id="playerBuildInfo" style="margin-top:8px;">—</div>
    </div>

    <div class="card">
      <div class="label">Ty</div>
      <div class="row" style="margin-top:10px;">
        <img class="avatar" id="playerIcon" alt="">
        <div>
          <div class="title" id="playerName">—</div>
          <div class="sub" id="playerInfo">—</div>
        </div>
      </div>

      <div class="label" style="margin-top:14px;">Vyber counter item (1 ze 3) – jen z poolu tvého champa (export) a nikdy item, který už máš</div>
      <div class="choices" id="choices"></div>

      <div class="result" id="result"></div>

      <div class="analysisBox" id="analysisBox" style="display:none;">
        <div class="t">Vysvětlení</div>
        <div class="small" id="reason"></div>
        <ul class="small" id="bullets"></ul>
      </div>

      <div style="margin-top:12px;">
        <button class="primary" id="nextBtn">Další</button>
      </div>
    </div>
  </div>
</main>

<footer>
  Fan-made projekt. Riot Games ho neschvaluje ani nesponzoruje. Assets: Riot Data Dragon. Statistiky: LeagueOfGraphs (offline export).
</footer>

<script>
(async function () {
  if ("serviceWorker" in navigator) {
    try { await navigator.serviceWorker.register("./sw.js"); } catch (e) {}
  }

  const el = (id) => document.getElementById(id);
  const patchMeta = el("patchMeta");
  const scoreEl = el("score");
  const streakEl = el("streak");
  const newBtn = el("newBtn");
  const nextBtn = el("nextBtn");

  let SCORE = 0;
  let STREAK = 0;
  let awaitingNext = false;

  const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };

  // ---------- Load export first ----------
  const logData = await fetch("./data/log_builds.json").then(r => r.json());

  if (!logData || !logData.champions) {
    patchMeta.textContent = "Chyba: data/log_builds.json se nenačetlo nebo má špatný formát (chybí .champions).";
    throw new Error("Bad log_builds.json format");
  }

  const RANKS = ["silver","gold"];

  // patch pin
  const versions = await fetch("https://ddragon.leagueoflegends.com/api/versions.json").then(r => r.json());
  const datasetPatch = (logData?.patch || logData?.meta?.patch || logData?.metadata?.patch || "").toString().trim();
  const patch = (datasetPatch && versions.includes(datasetPatch)) ? datasetPatch : versions[0];

  // ---------- DDragon ----------
  const champFull = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/championFull.json`).then(r => r.json());
  const champs = Object.values(champFull.data).map(c => ({
    id: c.id,
    name: c.name,
    tags: c.tags || [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/champion/${c.image.full}`
  }));

  const itemJson = await fetch(`https://ddragon.leagueoflegends.com/cdn/${patch}/data/en_US/item.json`).then(r => r.json());
  const rawItems = itemJson.data;
  const items = Object.entries(rawItems).map(([id, it]) => ({
    id: Number(id),
    name: it.name,
    gold: it.gold?.total ?? 0,
    tags: it.tags ?? [],
    icon: `https://ddragon.leagueoflegends.com/cdn/${patch}/img/item/${it.image.full}`,
    depth: it.depth ?? 0,
    requiredChampion: it.requiredChampion ?? null,
    inStore: it.inStore !== false
  }));
  const itemById = new Map(items.map(i => [i.id, i]));

  // ---------- Item relevance ----------
  const HARD_BANNED_ITEM_IDS = new Set([
    2003,2031,2033,2032,
    2055,
    3340,3363,3364,
    2010,2015,2019,2021,
    2051,2052,2138,2139,2140
  ]);

  function isRelevantItem(it) {
    if (!it) return false;
    if (!it.inStore) return false;
    if (it.requiredChampion) return false;
    if (HARD_BANNED_ITEM_IDS.has(it.id)) return false;
    if ((it.gold ?? 0) <= 0) return false;

    const tags = new Set(it.tags || []);
    if (tags.has("Consumable")) return false;
    if (tags.has("Trinket")) return false;

    const n = (it.name || "").toLowerCase();
    if (n.includes("ward") || n.includes("trinket") || n.includes("potion") || n.includes("elixir")) return false;

    return !!it.icon;
  }

  // ---------- LoG -> Riot item mapping (STRICT) ----------
  const normalizeName = (s) =>
    (s || "")
      .toLowerCase()
      .replace(/&/g, "and")
      .replace(/[’'`"]/g, "")
      .replace(/[^a-z0-9]+/g, "")
      .trim();

  const itemByNormName = new Map();
  for (const it of items) itemByNormName.set(normalizeName(it.name), it);

  const NAME_ALIASES = new Map([
    [normalizeName("Lord Dominik's Regards"), normalizeName("Lord Dominiks Regards")],
    [normalizeName("Zhonya's Hourglass"), normalizeName("Zhonyas Hourglass")]
  ]);

  function getRiotItemByLoGName(logName) {
    const n = normalizeName(logName);
    if (itemByNormName.has(n)) return itemByNormName.get(n);
    for (const [a, b] of NAME_ALIASES.entries()) {
      if (n === a && itemByNormName.has(b)) return itemByNormName.get(b);
      if (n === b && itemByNormName.has(a)) return itemByNormName.get(a);
    }
    return null;
  }

  function riotItemIdByName(name) {
    return itemByNormName.get(normalizeName(name))?.id ?? null;
  }

  // ---------- UI helpers ----------
  function setChamp(side, champ, extra) {
    el(`${side}Icon`).src = champ.icon;
    el(`${side}Icon`).alt = champ.name;
    el(`${side}Name`).textContent = champ.name;
    el(`${side}Info`).textContent = extra;
  }

  function renderIcons(containerId, itemList) {
    const wrap = el(containerId);
    wrap.innerHTML = "";
    for (const it of (itemList || [])) {
      const img = document.createElement("img");
      img.className = "mini";
      img.alt = it.name;
      img.title = it.name;
      img.src = it.icon + `?v=${Date.now()}`;
      img.onerror = () => img.remove();
      wrap.appendChild(img);
    }
  }

  function champFromSlug(slug) {
    const norm = (slug || "").toLowerCase().replace(/[^a-z0-9]/g,"");
    const found = champs.find(c => c.id.toLowerCase().replace(/[^a-z0-9]/g,"") === norm);
    return found || rand(champs);
  }

  // ---------- Export access ----------
  function getRows(slug, laneRaw, rank, phase) {
    const rows = logData?.champions?.[slug]?.[laneRaw]?.[rank]?.[phase];
    if (!Array.isArray(rows) || rows.length === 0) return null;
    return rows;
  }

  function getTopRow(slug, laneRaw, rank, phase) {
    const rows = getRows(slug, laneRaw, rank, phase);
    return rows ? rows[0] : null;
  }

  function getRelevantItemsFromRow(row, max = 6) {
    const out = [];
    for (const x of (row?.items || [])) {
      const mapped = getRiotItemByLoGName(x?.name);
      if (!mapped) continue;
      const it = itemById.get(mapped.id);
      if (!isRelevantItem(it)) continue;
      out.push(it);
      if (out.length >= max) break;
    }
    return out;
  }

  function parsePct(x) {
    if (x == null) return 0;
    if (typeof x === "number") return x;
    const s = String(x).trim().replace("%", "");
    const v = Number(s);
    return Number.isFinite(v) ? v : 0;
  }

  function itemIdSet(list) {
    const s = new Set();
    for (const it of (list || [])) s.add(it.id);
    return s;
  }

  // ---------- Pool (relaxed, no hard filters) ----------
  const POOL_TOP_N_ROWS = 18;

  function getPlayerPoolFromExport(playerSlug, laneRaw, rank, phase) {
    const rows = getRows(playerSlug, laneRaw, rank, phase);
    if (!rows) return null;

    const lim = Math.min(POOL_TOP_N_ROWS, rows.length);
    const weightByItemId = new Map();

    for (let i = 0; i < lim; i++) {
      const row = rows[i];
      const rowPick = parsePct(row?.pickRate);
      const w = rowPick > 0 ? rowPick : (1.0 / (i + 1));

      const itemsList = getRelevantItemsFromRow(row, 6) || [];
      for (const it of itemsList) {
        if (!isRelevantItem(it)) continue;
        weightByItemId.set(it.id, (weightByItemId.get(it.id) || 0) + w);
      }
    }

    const all = [];
    for (const [id, w] of weightByItemId.entries()) {
      const it = itemById.get(id);
      if (!it || !isRelevantItem(it)) continue;
      all.push(it);
    }

    all.sort((a,b) => (weightByItemId.get(b.id)||0) - (weightByItemId.get(a.id)||0));
    return all;
  }

  // ---------- Tier matching within pool ----------
  function tierBucket(it) {
    const g = it.gold || 0;
    const d = it.depth || 0;

    let band = 0;
    if (g <= 500) band = 0;
    else if (g <= 900) band = 1;
    else if (g <= 1400) band = 2;
    else if (g <= 2000) band = 3;
    else if (g <= 2600) band = 4;
    else if (g <= 3200) band = 5;
    else band = 6;

    let depthBand = 0;
    if (d <= 1) depthBand = 0;
    else if (d === 2) depthBand = 1;
    else if (d === 3) depthBand = 2;
    else depthBand = 3;

    return `${band}::${depthBand}`;
  }

  function pickTwoDistractorsFromPool(poolItems, correctId) {
    const correct = itemById.get(correctId);
    if (!correct) return null;

    const ctier = tierBucket(correct);
    const cgold = correct.gold || 0;
    const cdepth = correct.depth || 0;

    let candidates = poolItems.filter(it => it.id !== correctId && tierBucket(it) === ctier);
    if (candidates.length < 4) {
      candidates = poolItems.filter(it =>
        it.id !== correctId &&
        Math.abs((it.gold||0) - cgold) <= 600 &&
        Math.abs((it.depth||0) - cdepth) <= 1
      );
    }
    if (candidates.length < 2) candidates = poolItems.filter(it => it.id !== correctId);

    candidates = shuffle(candidates);
    const out = [];
    for (const it of candidates) {
      if (out.length >= 2) break;
      out.push(it.id);
    }
    return out.length === 2 ? out : null;
  }

  // ---------- Counter scoring ----------
  function buildEnemySignals(enemyItems) {
    const names = enemyItems.map(x => x.name.toLowerCase()).join(" | ");
    const armorCount = enemyItems.filter(it => (it.tags||[]).includes("Armor")).length;
    const hasShields = names.includes("sterak") || names.includes("seraph") || names.includes("immortal shieldbow");
    const hasLifesteal = names.includes("bloodthirst") || names.includes("ravenous") || names.includes("blade of the ruined king") || names.includes("riftmaker") || names.includes("vamp");
    const hasCrit = names.includes("infinity edge") || names.includes("phantom dancer") || names.includes("rapid firecannon") || names.includes("statikk") || names.includes("navori") || names.includes("the collector");
    return { armorHeavy: armorCount >= 2, hasLifesteal, hasShields, hasCrit };
  }

  const GW_IDS = new Set([
    riotItemIdByName("Morellonomicon"),
    riotItemIdByName("Mortal Reminder"),
    riotItemIdByName("Thornmail"),
    riotItemIdByName("Chempunk Chainsword")
  ].filter(Boolean));

  const ARMOR_PEN_IDS = new Set([
    riotItemIdByName("Lord Dominik's Regards"),
    riotItemIdByName("Serylda's Grudge"),
    riotItemIdByName("Black Cleaver"),
    riotItemIdByName("Terminus")
  ].filter(Boolean));

  const ANTI_SHIELD_IDS = new Set([riotItemIdByName("Serpent's Fang")].filter(Boolean));
  const ANTI_CRIT_IDS = new Set([riotItemIdByName("Randuin's Omen"), riotItemIdByName("Frozen Heart")].filter(Boolean));

  function laneKind(laneRaw) {
    const x = (laneRaw || "").toLowerCase().trim();
    if (x.includes("support") || x === "supp") return "SUPPORT";
    if (x === "adc" || x.includes("bot") || x.includes("bottom")) return "ADC";
    if (x.includes("jungle") || x === "jg") return "JUNGLE";
    if (x.includes("mid") || x.includes("middle")) return "MID";
    if (x.includes("top")) return "TOP";
    return "UNKNOWN";
  }

  function counterScore(enemyItems, candidateItem, playerChamp, laneRaw, phase) {
    const sig = buildEnemySignals(enemyItems);
    const id = candidateItem.id;
    const kind = laneKind(laneRaw);
    const pTags = new Set(playerChamp?.tags || []);
    const t = new Set(candidateItem.tags || []);

    let score = 0;

    if (sig.hasLifesteal && GW_IDS.has(id)) score += 6;
    if (sig.armorHeavy && ARMOR_PEN_IDS.has(id)) score += 5;
    if (sig.hasShields && ANTI_SHIELD_IDS.has(id)) score += 4.5;
    if (sig.hasCrit && ANTI_CRIT_IDS.has(id)) score += 4;

    const nm = candidateItem.name.toLowerCase();
    const isSupportish = nm.includes("mikael") || nm.includes("locket") || nm.includes("redemption");
    if (isSupportish && kind !== "SUPPORT") score -= 6;

    // weak class nudges
    if (pTags.has("Tank") && (t.has("Health") || t.has("Armor") || t.has("MagicResist"))) score += 0.6;
    if (pTags.has("Mage") && (t.has("SpellDamage") || t.has("Mana") || t.has("CooldownReduction"))) score += 0.6;
    if (pTags.has("Marksman") && (t.has("CriticalStrike") || t.has("AttackSpeed") || t.has("Damage"))) score += 0.6;

    // phase nudge
    const ph = (phase || "").toLowerCase();
    if (ph.includes("early")) {
      if ((candidateItem.gold||0) <= 1200) score += 1.0;
      if ((candidateItem.depth||0) <= 2) score += 0.6;
    }
    if (ph.includes("late")) {
      if ((candidateItem.gold||0) >= 2600) score += 0.8;
      if ((candidateItem.depth||0) >= 3) score += 0.5;
    }

    return score;
  }

  // ---------- Scenarios + PHASE rotation (forced early/mid/late) ----------
  const allSlugs = Object.keys(logData.champions || {});
  const scenariosByPhase = new Map();
  const scenariosByLane = new Map();
  const scenariosByKey = new Map();
  let totalScenarios = 0;

  function phaseBucket(phaseStr) {
    const p = (phaseStr || "").toLowerCase();
    if (p.includes("early")) return "early";
    if (p.includes("late")) return "late";
    return "mid";
  }

  for (const enemySlug of allSlugs) {
    const lanesObj = logData.champions[enemySlug] || {};
    for (const laneRaw of Object.keys(lanesObj)) {
      for (const rank of RANKS) {
        const rankObj = lanesObj[laneRaw]?.[rank] || {};
        for (const phase of Object.keys(rankObj)) {
          const enemyRow = getTopRow(enemySlug, laneRaw, rank, phase);
          if (!enemyRow) continue;

          const enemyItems = getRelevantItemsFromRow(enemyRow, 6);
          if (!enemyItems || enemyItems.length < 1) continue;

          const bucket = phaseBucket(phase);
          const sc = { laneRaw, rank, phase, bucket, enemySlug };
          const k = `${laneRaw}::${rank}::${phase}`;

          if (!scenariosByPhase.has(bucket)) scenariosByPhase.set(bucket, []);
          scenariosByPhase.get(bucket).push(sc);

          if (!scenariosByLane.has(laneRaw)) scenariosByLane.set(laneRaw, []);
          scenariosByLane.get(laneRaw).push(sc);

          if (!scenariosByKey.has(k)) scenariosByKey.set(k, []);
          scenariosByKey.get(k).push(sc);

          totalScenarios++;
        }
      }
    }
  }

  if (totalScenarios === 0) throw new Error("Žádné scénáře v exportu po filtrech.");

  const laneLines = [...scenariosByLane.entries()].sort((a,b)=>b[1].length-a[1].length).map(([l,a])=>`${l}:${a.length}`);
  const eCount = scenariosByPhase.get("early")?.length || 0;
  const mCount = scenariosByPhase.get("mid")?.length || 0;
  const lCount = scenariosByPhase.get("late")?.length || 0;

  patchMeta.textContent =
    `Patch: ${patch} • Dataset: data/log_builds.json\n` +
    `Scénáře: ${totalScenarios}\n` +
    `Fáze: early:${eCount} | mid:${mCount} | late:${lCount}\n` +
    `Lane: ${laneLines.join(" | ")}`;

  // forced phase alternation: early -> mid -> late -> repeat (skip empty)
  const phaseCycleBase = ["early","mid","late"];
  let phaseCycle = phaseCycleBase.slice();
  let phaseIdx = 0;

  function pickPhaseForced() {
    for (let t = 0; t < 3; t++) {
      const p = phaseCycle[phaseIdx % phaseCycle.length];
      phaseIdx++;
      if ((scenariosByPhase.get(p) || []).length > 0) return p;
    }
    // fallback
    const keys = [...scenariosByPhase.keys()];
    return keys.length ? rand(keys) : "mid";
  }

  // lane bag per phase bucket
  const laneBagByBucket = new Map();

  function nextScenario() {
    const bucket = pickPhaseForced();
    const list = scenariosByPhase.get(bucket) || [];
    if (!list.length) return rand([].concat(...[...scenariosByLane.values()]));

    const lanes = new Map();
    for (const sc of list) {
      if (!lanes.has(sc.laneRaw)) lanes.set(sc.laneRaw, []);
      lanes.get(sc.laneRaw).push(sc);
    }

    const laneKeys = [...lanes.keys()];
    const weights = laneKeys.map(l => 1 / Math.max(1, lanes.get(l).length));
    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random() * sum;
    let laneRaw = laneKeys[laneKeys.length-1];
    for (let i=0;i<laneKeys.length;i++) { r -= weights[i]; if (r<=0) { laneRaw = laneKeys[i]; break; } }

    if (!laneBagByBucket.has(bucket)) laneBagByBucket.set(bucket, new Map());
    const m = laneBagByBucket.get(bucket);
    if (!m.has(laneRaw) || m.get(laneRaw).length === 0) m.set(laneRaw, shuffle(lanes.get(laneRaw)));
    return m.get(laneRaw).pop();
  }

  // anti-repeat
  const RECENT_N = 10;
  const recentEnemies = [];
  const recentPlayers = [];
  const pushRecent = (arr, v) => { arr.push(v); while (arr.length > RECENT_N) arr.shift(); };

  function lockChoices(locked) {
    document.querySelectorAll("button.choice").forEach(b => b.disabled = locked);
  }

  let state = { correctId: null, correctName: "", why: "", bullets: [] };

  function renderAnalysis() {
    el("analysisBox").style.display = "block";
    el("reason").textContent = state.why;
    const ul = el("bullets");
    ul.innerHTML = "";
    for (const b of state.bullets || []) {
      const li = document.createElement("li");
      li.textContent = b;
      ul.appendChild(li);
    }
  }

  async function newRound() {
    awaitingNext = false;
    nextBtn.style.display = "none";
    nextBtn.disabled = true;
    newBtn.disabled = false;

    el("result").textContent = "";
    el("result").className = "result";
    el("choices").innerHTML = "";
    el("analysisBox").style.display = "none";
    el("reason").textContent = "";
    el("bullets").innerHTML = "";

    for (let tries = 0; tries < 2000; tries++) {
      const sc = nextScenario();
      const { laneRaw, rank, phase, enemySlug } = sc;

      if (recentEnemies.includes(enemySlug)) continue;

      const enemyRow = getTopRow(enemySlug, laneRaw, rank, phase);
      if (!enemyRow) continue;

      const enemyItems = getRelevantItemsFromRow(enemyRow, 6);
      if (!enemyItems || enemyItems.length < 1) continue;

      const k = `${laneRaw}::${rank}::${phase}`;
      const slugsInKey = scenariosByKey.get(k)?.map(x => x.enemySlug) || [];
      const candidatePlayers = [...new Set(slugsInKey)].filter(s => s !== enemySlug);
      if (!candidatePlayers.length) continue;

      const playerSlug = rand(candidatePlayers);
      if (recentPlayers.includes(playerSlug)) continue;

      const playerRow = getTopRow(playerSlug, laneRaw, rank, phase);
      if (!playerRow) continue;

      const playerItems = getRelevantItemsFromRow(playerRow, 6);
      if (!playerItems || playerItems.length < 1) continue;

      const owned = itemIdSet(playerItems);

      const poolRaw = getPlayerPoolFromExport(playerSlug, laneRaw, rank, phase);
      if (!poolRaw || poolRaw.length < 3) continue;

      // strict rule: never offer owned, but fallback if owned kills options
      let pool = poolRaw.filter(it => !owned.has(it.id));

      if (pool.length < 3) {
        // lighten owned: only top 3 items count as "already have"
        const ownedLite = new Set((playerItems || []).slice(0, 3).map(x => x.id));
        pool = poolRaw.filter(it => !ownedLite.has(it.id));
        if (pool.length < 3) continue;
      }

      const enemyChamp = champFromSlug(enemySlug);
      const playerChamp = champFromSlug(playerSlug);

      // correct = argmax over pool
      let best = null;
      let bestScore = -1e9;
      for (const it of pool) {
        const s = counterScore(enemyItems, it, playerChamp, laneRaw, phase);
        if (s > bestScore) { bestScore = s; best = it; }
      }
      if (!best) continue;

      const correctId = best.id;
      const wrongIds = pickTwoDistractorsFromPool(pool, correctId);
      if (!wrongIds) continue;

      const ids = shuffle([correctId, ...wrongIds]);
      if (new Set(ids).size !== 3) continue;
      if (ids.some(id => !itemById.get(id))) continue;
      if (ids.some(id => owned.has(id))) {
        // safety: if any owned slipped in (shouldn't), reroll
        continue;
      }

      // UI
      setChamp("enemy", enemyChamp, `Lane: ${laneRaw} • Rank: ${rank} • Fáze: ${phase}`);
      setChamp("player", playerChamp, `Lane: ${laneRaw} • Rank: ${rank} • Fáze: ${phase}`);

      renderIcons("enemyBuildIcons", enemyItems);
      renderIcons("playerBuildIcons", playerItems);

      el("enemyBuildInfo").textContent =
        `Pick: ${enemyRow?.pickRate ?? "—"}% • Win: ${enemyRow?.winRate ?? "—"}% • (top row exportu)`;

      el("playerBuildInfo").textContent =
        `Pick: ${playerRow?.pickRate ?? "—"}% • Win: ${playerRow?.winRate ?? "—"}% • (top row exportu)`;

      const chosenName = itemById.get(correctId)?.name || "—";
      const enemyList = enemyItems.map(x=>x.name).join(", ");
      const playerList = playerItems.map(x=>x.name).join(", ");
      const sig = buildEnemySignals(enemyItems);
      const bullets = [];

      if (GW_IDS.has(correctId) && sig.hasLifesteal) bullets.push("Oponent má sustain/lifesteal → GW zmenší heal a přetlačí trades.");
      if (ARMOR_PEN_IDS.has(correctId) && sig.armorHeavy) bullets.push("Oponent má více armor itemů → bez pen/shredu mu neublížíš.");
      if (ANTI_SHIELD_IDS.has(correctId) && sig.hasShields) bullets.push("Oponent má shield itemy → Serpent’s Fang snižuje efektivní HP.");
      if (ANTI_CRIT_IDS.has(correctId) && sig.hasCrit) bullets.push("Oponent má crit/AA DPS → Randuin/Frozen Heart sníží jeho DPS.");
      if (bullets.length === 0) bullets.push("Z tvého reálně hraného poolu (export) je to nejlepší odpověď na profil enemy itemů v této fázi.");

      state.correctId = correctId;
      state.correctName = chosenName;
      state.why = `Fáze: ${phase}. Enemy itemy: ${enemyList}. Ty (top build): ${playerList}. Volby jsou pouze z poolu itemů, které tvůj champion v této situaci reálně hraje (top ${POOL_TOP_N_ROWS} řádků exportu), a nikdy se nenabízí item, který už máš postavený.`;
      state.bullets = bullets;

      el("choices").innerHTML = "";
      for (const id of ids) {
        const it = itemById.get(id);
        const btn = document.createElement("button");
        btn.className = "choice";
        btn.innerHTML = `<img src="${it.icon}?v=${Date.now()}" alt="${it.name}"><div class="nm">${it.name}</div>`;
        btn.onclick = () => onPick(id);
        el("choices").appendChild(btn);
      }

      pushRecent(recentEnemies, enemySlug);
      pushRecent(recentPlayers, playerSlug);
      return;
    }

    el("result").textContent = "Chyba: nelze vygenerovat validní kolo.";
    el("result").className = "result bad";
  }

  function onPick(id) {
    if (awaitingNext) return;
    awaitingNext = true;

    lockChoices(true);
    newBtn.disabled = true;

    const ok = id === state.correctId;

    if (ok) {
      SCORE += 1;
      STREAK += 1;
      el("result").textContent = "SPRÁVNĚ";
      el("result").className = "result ok";
    } else {
      STREAK = 0;
      el("result").textContent = `ŠPATNĚ • Správně: ${state.correctName}`;
      el("result").className = "result bad";
    }

    scoreEl.textContent = String(SCORE);
    streakEl.textContent = String(STREAK);

    renderAnalysis();

    nextBtn.style.display = "inline-block";
    nextBtn.disabled = false;
  }

  newBtn.addEventListener("click", () => { if (!awaitingNext) newRound(); });
  nextBtn.addEventListener("click", () => newRound());

  await newRound();
})();
</script>
</body>
</html>
